{
  "hash": "6512dc44c94c3d2de48ee967159d5fde",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Vectorization and recursion\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\n---\n\n\n## Overview of today\n\n-   Vectorization\n-   Recursion\n-   Lab time\n\n## Vectorization\n\nLast class, we saw how to use `for` and `while` loops to repeat tasks. However, often in R, functions or operations are vectorized, meaning they automatically act on every entry in a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nx * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 8\n```\n:::\n:::\n\n\n## Vectorization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nx < 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE FALSE\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\ny <- 4:1\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5 5 5\n```\n:::\n:::\n\n\n## Vectorization with data\n\nWe often rely on vectorization when working with columns of a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nlibrary(tidyverse)\ndata(penguins)\npenguins <- penguins |>\n  mutate(bill_len_dep_ratio = bill_length_mm / bill_depth_mm)\npenguins$bill_len_dep_ratio\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 2.090909 2.270115 2.238889       NA 1.901554 1.907767 2.185393 2.000000\n  [9] 1.883978 2.079208 2.210526 2.184971 2.335227 1.820755 1.639810 2.056180\n [17] 2.036842 2.053140 1.869565 2.139535 2.065574 2.016043 1.869792 2.110497\n [25] 2.255814 1.867725 2.182796 2.262570 2.037634 2.142857 2.365269 2.055249\n [33] 2.219101 2.164021 2.141176 1.857820 1.940000 2.281081 1.948187 2.083770\n [41] 2.027778 2.217391 1.945946 2.238579 2.189349 2.106383 2.163158 1.984127\n [49] 2.011173 1.995283 2.237288 2.121693 1.955307 2.153846 1.906077 2.225806\n [57] 2.228571 2.159574 2.198795 1.968586 2.112426 1.957346 2.211765 2.258242\n [65] 2.128655 2.311111 2.191358 2.151832 2.162651 2.154639 1.763158 2.157609\n [73] 2.302326 2.423280 2.028571 2.313514 2.434524 1.917526 2.248447 2.204188\n [81] 2.011628 2.437500 1.952128 1.809278 2.095506 2.034483 1.861538 1.983871\n [89] 1.994792 2.069149 1.983333 2.270718 1.988304 2.187845 2.092486 2.158730\n [97] 2.048387 2.178378 2.055901 2.335135 1.955307 2.050000 2.356250 1.890000\n[105] 2.037634 2.100529 2.244186 1.910000 2.241176 2.273684 2.309091 2.246305\n[113] 2.242938 2.164103 1.913043 2.333333 2.270588 1.819512 2.100000 2.209677\n[121] 2.104651 1.904040 2.364706 2.237838 2.213836 2.136842 2.204545 2.267760\n[129] 2.280702 2.450000 2.150838 2.244792 1.989189 2.027027 2.164773 2.348571\n[137] 2.034286 2.000000 2.242424 2.217877 2.350877 2.360465 2.070968 2.394118\n[145] 2.220238 2.085561 2.107527 1.989130 2.022472 2.088398 2.105263 2.243243\n[153] 3.492424 3.067485 3.453901 3.289474 3.282759 3.444444 3.109589 3.052288\n[161] 3.231343 3.038961 2.985401 3.043478 3.321168 3.315068 3.136986 3.140127\n[169] 3.111111 3.236842 3.186207 3.225166 3.510490 3.110345 3.206897 2.930380\n[177] 3.274809 3.052980 3.111888 3.186667 3.370629 3.267974 3.091503 3.014085\n[185] 3.110345 3.505882 3.317568 2.969325 3.109489 2.566474 3.235294 3.101911\n[193] 3.116788 3.100000 3.306569 3.306667 3.176101 3.136691 3.273381 3.176101\n[201] 3.375940 2.860759 3.281690 3.439716 3.131944 3.340000 3.229167 2.922078\n[209] 3.151079 3.033333 2.979310 3.294118 3.282609 3.100671 3.287770 3.458599\n[217] 3.225352 2.964286 3.208333 3.055556 3.063380 3.380000 3.180000 2.974359\n[225] 3.089744 3.141892 3.093333 3.037500 3.345070 3.134969 3.275362 2.756098\n[233] 3.386207 3.365385 3.246575 3.144654 3.253623 2.936416 3.013889 3.612676\n[241] 3.392857 3.064706 3.166667 3.052632 3.137931 3.074534 3.027211 3.235669\n[249] 3.126582 3.212329 3.361111 3.096970 3.233333 3.288235 3.045161 3.273333\n[257] 3.427536 2.906832 2.836735 3.379747 3.092857 3.185430 3.322368 3.132075\n[265] 2.861842 3.159509 3.276596 3.443750 2.834395 3.012346 3.445255       NA\n[273] 3.272727 3.210191 3.054054 3.099379 2.597765 2.564103 2.671875 2.427807\n[281] 2.661616 2.539326 2.532967 2.818681 2.433862 2.577889 2.617978 2.546798\n[289] 2.716763 2.872928 2.684211 2.576531 2.515000 3.258427 2.494624 2.703297\n[297] 2.450867 2.771429 2.602410 2.608247 2.608939 2.736842 2.744565 2.605263\n[305] 2.606742 2.640000 2.463855 2.605769 2.544910 2.712766 2.672043 2.827381\n[313] 2.601093 2.512077 2.825301 2.688442 2.512821 2.640000 2.664921 2.676471\n[321] 2.843575 2.745946 2.798883 2.500000 2.754011 2.878613 2.932927 2.705263\n[329] 2.641618 2.573604 2.456647 2.776596 2.722892 2.477387 2.670213 2.350515\n[337] 2.661538 2.836364 2.688235 2.818182 2.403315 2.725275 2.673684 2.684492\n```\n:::\n:::\n\n\n## Vectorization in functions\n\nOften we desire our function to be vectorized: so that it can take in vectors as inputs and perform an operation/task for each entry of the vector(s).\n\nFor this reason, it is important to begin remembering which functions are vectorized/vectorizable.\n\n## Absolute error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_forecasts <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-12-20/weather_forecasts.csv')\nweather_forecasts <- weather_forecasts |>\n  mutate(abs_err_precip = abs(observed_temp - forecast_temp))\n```\n:::\n\n\n**Exercise**: Write a function that takes as input two vectors of length $n$, `observed` and `predicted` and returns a vector of length $n$ of the absolute errors.\n\n## Absolute error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabsolute_error <- function(observed, predicted) {\n  return(abs(observed - predicted))\n}\n```\n:::\n\n\n## Squared error\n\n**Exercise**: Write a function that takes as input two vectors of length $n$, `observed` and `predicted` and returns a vector of length $n$ of the squared errors.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquared_error <- function(observed, predicted) {\n  return((observed - predicted)^2)\n}\n```\n:::\n\n\n## Why not vectorize?\n\n-   modifying in place\n-   `while` loops\n-   recursive functions\n\n## Modifying in place\n\nSometimes we wish to change the value of some object iteratively. In such cases, vectorizing code may not be possible.\n\nWhat do you expect the output of this code to be?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nfor (i in 10:1) {\n  x[i] <- sum(x[1:i])\n}\nx\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  3  6 10 15 21 28 36 45 55\n```\n:::\n:::\n\n\n. . .\n\nThese are known as the triangular numbers.\n\n## Recursion\n\nRecursion is a method for solving a problem where the solution can be divided into simpler or smaller versions of the same problem.\n\n**Example**: Factorial function\n\n. . .\n\n**Example**: Fractals\n\n![](https://mathworld.wolfram.com/images/eps-svg/Fractal1_1000.svg){fig-align=\"center\"}\n\n## Recursive functions: factorial\n\nRecursive functions are those that call themselves to solve problems.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfact <- function(x) {\n  if (x == 0 | x == 1) {\n    return(1)\n  } else {\n    return(x * fact(x - 1))\n  }\n}\nfact(4)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n:::\n\n\n## Recursive functions: Fibonacci\n\nExercise: write a function `fibonacci()` that takes as input a natural number `n` and returns the $n$th Fibonacci number.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfibonacci <- function(n) {\n  if (n == 1 | n == 2) {\n    return(1)\n  } else {\n    return(fibonacci(n - 1) + fibonacci(n - 2))\n  }\n}\nfibonacci(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n:::\n\n\n## Recursive functions: Prime factorization\n\nChallenge: write a function `factorize()` that takes as input a natural number `n` and returns its prime factorization.\n\n. . .\n\nHow might we get started with this question?\n",
    "supporting": [
      "14_vectorization-recursion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}