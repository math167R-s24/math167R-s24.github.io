{
  "hash": "3a7e37490fba07137b6c275cbc7d3140",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Environment and Scope\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\n---\n\n\n## Overview of today\n\n-   Advanced functions\n-   Environments and scope (based on *Advanced R* by Hadley Wickham)\n-   Lab time\n\n## Function composition\n\nIn mathematics, function composition is an operation that combines functions:\n\nFor example, if $f(x) = x^2$ and $g(x)=x+2$, what is $f(g(x))$?\n\nThroughout this class we have been composing functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nprint(sum(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n:::\n\n\n. . .\n\nWe can also compose functions using pipes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> sum() |> print()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n:::\n\n\n## Function structure in `R`\n\nMost functions in R have three parts:\n\n-   `formals()`: the list of formal arguments\n\n-   `body()`: the code inside the function\n\n-   `environment()`: the data structure that determines how objects and values are found when evaluating the function\n\n## Environments and scoping\n\nPreviously, we talked about assignment in `R`, which binds names to values.\n\nToday we'll talk about **scoping**, which involves finding a value associated with a name.\n\nExercise: What will the following code return?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\nmy_function <- function() {\n  return(x)\n}\nmy_function()\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n## Environments and scoping\n\nExercise: What about this code?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\nmy_function <- function() {\n  x <- 20\n  return(x)\n}\nmy_function()\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n\n## Lexical scoping\n\nR generally uses **lexical scoping** meaning that a function accesses values of names based on how the function is defined and not how it is called.\n\n## Name masking\n\n**Name masking**: names defined within a function mask names defined outside the function.\n\n**Exercise**: What will the following code return?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 20\nmy_function <- function() {\n  x <- 1\n  y <- 2\n  return(c(x, y))\n}\nmy_function()\nprint(x)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n## Name masking\n\nNow, `y` is a **free variable**, meaning that it is not defined as a formal argument or declared in the body of the function?\n\n**Exercise**: What will the following code return?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\ny <- 20\nmy_function <- function() {\n  x <- 1\n  return(c(x, y))\n}\nmy_function()\nprint(x)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 20\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n## Free variables\n\nLexical scoping means that free variables are searched for in the **environment** where the function is defined.\n\n## Environments\n\nAn environment is a collection of pairs of symbols (names) and values.\n\nWe can think of environments as simply bags of names bound to values (figure from *Advanced R*)\n\n![](https://d33wubrfki0l68.cloudfront.net/f5dbd02f5235283e78decdd4f18692b40f1ddf42/c5683/diagrams/environments/bindings.png){fig-align=\"center\"}\n\n## Environments\n\nEnvironments are organized hierarchically: Every environment has a parent and may have one or multiple children.\n\nThere is one environment without a parent: the empty environment.\n\n![](https://d33wubrfki0l68.cloudfront.net/ff7bec1ccb1455917a6c9d0f44f114ef5c78519f/39793/diagrams/environments/parents-empty.png){fig-align=\"center\"}\n\n## The global environment\n\nWhen we work in RStudio and interact with the console, we are generally working in the **global environment**. The global environment is often called the workspace.\n\nWhen we try to access a variable in the console (or click Run when editing an R Markdown document), we are working in the global environment.\n\n## Package environments\n\nWhenever we load a package with `library()` we add a parent to the global environment:\n\n![](https://d33wubrfki0l68.cloudfront.net/038b2da4f5db1d2a8acaf4ee1e7d08d04ab36ebc/ac22a/diagrams/environments/search-path.png){fig-align=\"center\"}\n\nWe can see the current search path using the `search()` function.\n\n## Searching for a value\n\nSuppose we are looking for a value for a given symbol used in a function.\n\n1.  First, the search begins within the body of the function.\n2.  Next, if the value is not found in the body, the search continues in the function's environment (where it was defined).\n3.  If the value is not found there, the search continues in the parent environment.\n4.  The search continues up the sequence of parents until the empty environmnet is reached at which point we throw an error.\n\n## Example\n\n**Exercise**: What will the following code return?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  f <- function(x) {\n    f <- function() {\n      x ^ 2\n    }\n    f() + 1\n  }\n  f(x) * 2\n}\nf(10)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 202\n```\n:::\n:::\n\n\n## Knitting/Rendering an R Markdown document\n\nWhen you open RStudio, you are working in a (new) global environment.\n\nWhen we click Run within RStudio, you are working in this same global environment.\n\nHowever, when you knit an R Markdown document, you are essentially starting a new global environment, so you cannot access anything in your current workspace.\n\nThis ensures that the R Markdown document is **self-contained** and has everything that one would need to reproduce your results.\n\n## A fresh start: function execution\n\nEach time you **execute** a function by calling it, a temporary environment is created.\n\n**Exercise**: What will the following code return?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function() {\n  if (!exists(\"a\")) {\n    a <- 1\n  } else {\n    a <- a + 1\n  }\n  a\n}\nf()\nf()\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\n## Super assignment\n\nThe `<<-` operator doesn't create a variable in the current environment. It looks for a matching name in the parent environments. If it finds one, it updates that variable. If it doesn't, it creates a variable in the **global environment**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nf <- function() {\n  x <<- 1\n}\nf()\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\n## Practical tips\n\nRemember:\n\n-   **Name masking**: names defined within a function mask names defined outside the function.\n\n-   **Free variables**: Free variables are searched for first in the environment where the function is defined.\n\n-   **Knitting an R Markdown document**: R Markdown documents are self-contained, so when you knit, you cannot access anything in the global environment you were working in.\n\n-   **Function execution environments**: Function execution environments are generally temporary, so whatever happens within a function does not affect the global environment.\n",
    "supporting": [
      "15_environment-scope_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}