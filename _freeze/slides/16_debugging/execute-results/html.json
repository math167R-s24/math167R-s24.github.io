{
  "hash": "c18296d813f5650d2960f01ad9f6f7a6",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Debugging\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\n---\n\n\n## Overview of today\n\n-   Debugging (based on [Jennifer Bryan and Jim Hester's What they Forgot to Teach You About R - Debugging R Code](https://rstats.wtf/debugging-r-code.html))\n\n# What to do when your code doesn't work\n\n## Step 1: Look online\n\nWhen you see an error code you don't understand, search for it!\n\nSearch for the **exact text** of your error message (except for any references to filepaths, etc.).\n\nR has millions of users and an incredibly active online community. If you encounter any error message, chances are someone has had to debug that exact error in the past.\n\n## Step 2: Reset\n\nMany, many issues will be solved by closing and re-opening R.\n\nSometimes, things get weird with your global environment, and you just need to start with a clean slate. It can be frustrating, because you don't know what was causing the issue, but also a relief, because it will be fixed.\n\nResetting will:\n\n-   Clear your workspace (better than `rm(list = ls()`!)\n-   Reset your options to their defaults (an easy one to miss!)\n-   Clear your search path (the order R looks for things)\n\n## Step 3: Repeat\n\nWhen you encounter a bug, try to repeat it. Likely, it came about for a reason.\n\nWhen you do repeat it, you should repeat it with a minimal working example. This means you should remove as much code and simplify as much data as possible.\n\n-   Small and simple inputs\n-   No extraneous packages\n-   No unnecessary function calls\n\nExample: did your function break with a large data matrix of real-world data stored within a package? How about if you just use a $3\\times 3$ matrix of $1$'s?\n\n## Step 4: Locate\n\nIf you weren't able to fix a bug the \"easy\" way (found the solution online or just needed a reset), and you have a minimal working example demonstrating your bug, then you are ready for the really hard part: finding the bug.\n\nOften (not always), once you find a bug, it is rather easy to fix.\n\n## `traceback()`: call stack\n\nSometimes functions(in functions(in functions(in functions(...)))) can get complicated.\n\n**Exercise**: What will the following code return?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(a) g(a)\ng <- function(b) h(b)\nh <- function(c) i(c)\ni <- function(d) {\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\nf(5)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n## `traceback()`: call stack\n\nWhat about this code?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(a) g(a)\ng <- function(b) h(b)\nh <- function(c) i(c)\ni <- function(d) {\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\nf(1:3)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11 12 13\n```\n:::\n:::\n\n\n## `traceback()`: call stack\n\nWhat about this code?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(a) g(a)\ng <- function(b) h(b)\nh <- function(c) i(c)\ni <- function(d) {\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\nf(\"a\")\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n```\nError: `d` must be numeric\n```\n:::\n:::\n\n\n. . .\n\nWhy doesn't it say `'a' must be numeric`?\n\n## `traceback()`: call stack\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntraceback()\n```\n:::\n\n\n```         \n5: stop(\"`d` must be numeric\", call. = FALSE) \n4: i(c) \n3: h(b) \n2: g(a) \n1: f(\"a\")\n```\n\n## `traceback()`: call stack\n\nThis is called a **call stack**.\n\nRead from bottom to top:\n\n1.  First call was to `f(\"a\")`\n2.  Second call was `g(a)`\n3.  Third call was `h(b)`\n4.  Fourth call was `i(c)`\n5.  Fifth and last call was our error message, so we know `i(c)` triggered our error.\n\nWe now know that our error occurred within `i(c)`, but we don't know *where* within `i(c)` our error occurred.\n\n## `traceback()`: call stack\n\nNote this is done in your **Console**, not your **Editor** pane. This is typically not a part of your reproducible workflow, this is you figuring out your own problems until you fix what actually belongs in your workflow.\n\nOnce you have the bug fixed, *then* put the debugged code in your Editor pane. In general, most debugging will be done through the **Console**.\n\n## `print(), cat(), str()`: messages\n\nUse `print()` statements to test out `print()` statements to see the values used during execution.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2\"}\ni <- function(d) {\n  print(d)\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\nf(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError: `d` must be numeric\n```\n:::\n:::\n\n\n. . .\n\nThis is a quick and easy way to find bugs quickly and should be probably your first step when manually debugging.\n\n## `print(), cat(), str()`: messages\n\nTake your function and throw in a `cat()` statement to see what the function is seeing.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-3\"}\ni <- function(d) {\n  cat(\"The value of input parameter d is:\", d, \"\\n\")\n  cat(\"The class of input parameter d is:\", class(d), \"\\n\")\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\nf(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe value of input parameter d is: a \nThe class of input parameter d is: character \n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError: `d` must be numeric\n```\n:::\n:::\n\n\n## `print(), cat(), str()`: messages\n\nWe can similarly use `str()`:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2\"}\ni <- function(d) {\n  str(d)\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\nf(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr \"a\"\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError: `d` must be numeric\n```\n:::\n:::\n\n\nMore specifically, `str()` can be used to see *the structure of* what the function is seeing. This can often be more informative if the structure is not what you expect (a common source of bugs).\n\n## `print(), cat(), str()`: messages\n\nThe main downside to these approaches is that it can get messy quickly if you use multiple print statements, and you cannot further investigate the object. However, many bugs come down to typos or other trivial errors, and print statements are often all you need.\n\n## `browser()`: Interactive debugger\n\nSometimes, it may not be enough to just use print statements and locate a bug. You can get more information and interact with that information using `browser()`, an interactive debugger.\n\nWithin RStudio, you can also get right to an interactive debugger by clicking `Rerun with Debug`.\n\n## `browser()`: Interactive debugger\n\nAlternatively, we can plug `browser()` into our function, as with the print statements.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2\"}\ni <- function(d) {\n  browser()\n  if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n  }\n  d + 10\n}\nf(\"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCalled from: i(c)\ndebug at <text>#3: if (!is.numeric(d)) {\n    stop(\"`d` must be numeric\", call. = FALSE)\n}\ndebug at <text>#4: stop(\"`d` must be numeric\", call. = FALSE)\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError: `d` must be numeric\n```\n:::\n:::\n\n\n## `browser()`: Interactive debugger\n\nAfter you run a function with `browser()`, you will be *inside* of your function with an interactive debugger.\n\nYou will know it worked if you see a special prompt: `Browse[1]>`.\n\nWe can see:\n\n-   The environment within the function using the Environment pane\n-   The call stack using the new Traceback pane\n-   Special interactive debugging commands\n\n## Interactive debugging commands\n\n-   Next, `n`: executes the next step in the function. (If you have a variable named `n`, use `print(n)` to display its value.)\n\n-   Step into, `s`, works like next, but if the next step is a function, it will step into that function so you can explore it interactively. (Easy to get lost!)\n\n-   Finish, or `f`: finishes execution of the current loop or function. Useful to skip over long for loops you don't need to interact with.\n\n-   Continue, `c`: leaves the debugger and continues execution of the function. Useful if you've fixed the bad state and want to check that the function proceeds correctly.\n\n-   Stop, `Q`: exits the debugger and returns to the R prompt.\n\n## Interactive debugging commands\n\n-   Enter (no text): repeat the previous interactive debugging command. Defaults to Next `n` if you haven't used any debugging commands yet.\n\n-   `where`: prints stack trace of active calls (the interactive equivalent of `traceback`).\n\n## Other useful things to do\n\n-   `ls()`: List the current environment. You can use this to browse everything that the function is able to see at that moment.\n\n-   `str()`, `print()`: examine objects as the function sees them.\n\n## A warning\n\nIf you execute the step of a function where the error occurs, you will exit interactive debugging mode, the error message will print, and you will be returned to the R prompt.\n\nThis can get annoying, because it stops you from interacting right when you hit the bug.\n\nStrategy: \n* Call `browser()` and execute until you hit the error. Remember exactly where it occurs. \n* Call `browser()` again and execute again, stopping just before triggering the error. * You can copy and paste the next line of code into the `Browse` console to trigger the error without exiting the interactive debugger.\n\n## Tips\n\n-   Within the debugging section, you are interacting with the exact environment R is using before the error is triggered.\n-   Examine each object one-by-one in the environment to make sure the structure matches expectations.\n-   If you still can't figure it out, `s` \"Step into\" the next function and repeat this process.\n\n## Example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_p_norm <- function(p = 2) {\n  return(\n    function(x) return(sum(abs(x) ^ p) ^ (1 / p))\n  )\n}\ncalculate_p_norm <- function(x, p) {\n  # browser()\n  norm_fn <- create_p_norm(p)\n  return(norm_fn(x))\n}\ncalculate_p_norm(1:5, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\nWithin an interactive debugging environment, you can use `as.list(environment())` to see what is in the environment.\n\n## Example\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloop_fun <- function(x) {\n  # browser()\n  n <- length(x)\n  y <- rep(NA, n)\n  z <- rep(NA, n)\n  for (i in 1:n) {\n    y[i] <- x[i] * 2\n    z[i] <- y[i] * 2\n  }\n  return(list(\"y\" = y, \"z\" = z))\n}\nloop_fun(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$y\n[1]  2  4  6  8 10\n\n$z\n[1]  4  8 12 16 20\n```\n:::\n\n```{.r .cell-code}\nloop_fun(diag(1:5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$y\n [1]  2  0  0  0  0  0  4  0  0  0  0  0  6  0  0  0  0  0  8  0  0  0  0  0 10\n\n$z\n [1]  4  0  0  0  0  0  8  0  0  0  0  0 12  0  0  0  0  0 16  0  0  0  0  0 20\n```\n:::\n:::\n\n\n## Debugging Summary\n\n### 1. Search online.\n\n### 2. Reset.\n\n### 3. Repeat.\n\n### 4. Locate:\n\n-   Call stack: `traceback()`\n-   Non-interactive messages: `print()`, `cat()`, `str()`\n-   Interactive debugging: `browser()`, `debug()`, `debugonce()`, `trace()`\n\n## Debugging Resources\n\n-   [Advanced R Debugging - Hadley Wickham](https://adv-r.hadley.nz/debugging.html)\n-   [What they Forgot to Teach You About R - Jennifer Bryan and Jim Hester](https://rstats.wtf/debugging-r-code.html)\n-   [Debugging Techniques in RStudio - Amanda Gadrow](https://resources.rstudio.com/wistia-rstudio-conf-2018-2/debugging-techniques-in-rstudio-amanda-gadrow-4)\n-   [Debugging with RStudio Article - Jonathan McPherson](https://support.rstudio.com/hc/en-us/articles/200713843)\n-   [Introduction to debugging in R and RStudio - Jim Hester](https://www.jimhester.com/talk/2019-crug-debugging/)\n-   [Cheatsheet](https://github.com/ajmcoqui/debuggingRStudio/blob/b70a3575a3ff5e7867b05fb5e84568abba426c4b/RStudio_Debugging_Cheatsheet.pdf)\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}