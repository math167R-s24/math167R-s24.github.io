{
  "hash": "77b8cd1448ccc90dcb36e7ff120db0c2",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Functions and Loops\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\n---\n\n\n## Overview of today\n\n-   Writing R functions\n-   Loops\n-   Vectorization\n-   Recursion\n\n## Anatomy of a function\n\nRecall the structure of a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(param1, param2 = \"default\") {\n  # body of the function\n  return(output)\n}\n```\n:::\n\n\n-   `function_name`: the name you want to give your function, what you will use to call it\n-   `function()`: call this to define a function\n-   `param1`, `param2`: formal arguments input by the user. You can assign default values by setting them equal to something in the call to `function()`\n-   **body**: the actual code that is executed\n-   `return()`: the output value **returned** to the user\n\n## Exercise: degrees to radians\n\n\n\nWrite a function `degreesToRadians` that takes as input one number, `degrees`, and returns its value in radians. You do not need to check the data type of the input.\n\n## Exercise: degrees to radians\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegreesToRadians <- function(degrees) {\n  return((degrees / 360) * 2 * pi)\n}\ndegreesToRadians(180)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.141593\n```\n:::\n:::\n\n\n## Additional notes on functions\n\n\n\n-   *How do I know if a function is working*?\n\n    -   Test it on easy examples for which you know the results\n    -   When using `if`, test all the possible cases\n\n## Loops\n\n\n\n**Loops** enable us to repeat a line/lines of code many times.\n\nR provides three types of explicit loops: `for`, `while`, and `repeat`. We will focus on `for` and `while`.\n\n## `for` loops\n\n\n\n`for` loops repeat a chunk of code for each value of a vector.\n\n::: center\n`for (name in vector) {body}`\n:::\n\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:8) {\n  print(i)\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n```\n:::\n:::\n\n\n## Example: Vector sum\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1:10)\nsum(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n\n```{.r .cell-code}\ntotal_sum <- 0\nfor (i in x) {\n  total_sum <- total_sum + i\n}\nprint(total_sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n:::\n\n\n## Example: Fibonacci sequence\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code to compute the first 10 Fibonacci numbers\nfib_10 <- numeric(10) # empty numeric vector of length 10\nfib_10[1] <- 1\nfib_10[2] <- 1\nfor (i in 3:10) {\n  fib_10[i] <- fib_10[i - 1] + fib_10[i - 2]\n}\nfib_10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  1  2  3  5  8 13 21 34 55\n```\n:::\n:::\n\n\n## `while` loops\n\n\n\n`while` loops continuously evaluate the inner code chunk until the condition is `FALSE`.\n\nBe careful here: It is possible to get stuck in an infinite loop!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nwhile (x < 5) {\n  cat(\"x is currently\", x, \". Let's increase it by 1.\")\n  x <- x + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is currently 0 . Let's increase it by 1.x is currently 1 . Let's increase it by 1.x is currently 2 . Let's increase it by 1.x is currently 3 . Let's increase it by 1.x is currently 4 . Let's increase it by 1.\n```\n:::\n:::\n\n\n## `while` loops\n\n\n\nLet's see if we can clean up that output. Add `\"\\n\"` to a string to force a line break.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nwhile (x < 5) {\n  cat(\"x is currently \", x, \". Let's increase it by 1! \\n\", sep = \"\")\n  x <- x + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is currently 0. Let's increase it by 1! \nx is currently 1. Let's increase it by 1! \nx is currently 2. Let's increase it by 1! \nx is currently 3. Let's increase it by 1! \nx is currently 4. Let's increase it by 1! \n```\n:::\n:::\n\n\n## Example: String input\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring_vector <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nfor (mystring in string_vector) {\n  print(mystring)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n[1] \"e\"\n```\n:::\n:::\n\n\n## Nested Loops\n\nIn nested loops, the innermost loop iterates most quickly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounter <- 0\nfor (i in 1:3) {\n  for (j in 1:2) {\n    counter <- counter + 1\n    cat(\"i = \", i, \", j = \", j, \", counter = \", counter, \"\\n\", sep = \"\")\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ni = 1, j = 1, counter = 1\ni = 1, j = 2, counter = 2\ni = 2, j = 1, counter = 3\ni = 2, j = 2, counter = 4\ni = 3, j = 1, counter = 5\ni = 3, j = 2, counter = 6\n```\n:::\n:::\n\n\n## Nested Loops\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  for (j in 1:2) {\n    print(i * j)\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 2\n[1] 4\n[1] 3\n[1] 6\n```\n:::\n:::\n\n\n## Filling in a vector\n\nNote: Usually, this is an inefficient way to do this. We will see a faster way to work with vectors next class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Inefficient\nx <- rep(NA, 5)\nfor (i in 1:5) {\n  x[i] <- i * 2\n}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n\n```{.r .cell-code}\n# Much better\nx <- seq(2, 10, by = 2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\n## Filling in a vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nx <- rep(NA, 5)\nmy_strings <- c(\"a\", \"a \", \"a c\", \"a ca\", \"a cat\")\nfor (i in 1:5) {\n  x[i] <- str_length(my_strings[i])\n  print(x)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 NA NA NA NA\n[1]  1  2 NA NA NA\n[1]  1  2  3 NA NA\n[1]  1  2  3  4 NA\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n## Filling in a matrix\n\nNote: Usually, this is an inefficient way to do this. We will see a faster way to work with vectors next class.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(NA, nrow = 4, ncol = 3)\nfor (i in 1:4) {\n  for (j in 1:3) {\n    x[i, j] <- i * j\n  }\n}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    2    4    6\n[3,]    3    6    9\n[4,]    4    8   12\n```\n:::\n:::\n\n\n## Continue until positive sample\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(3)\nx <- -1\nwhile (x < 0) {\n  x <- rnorm(1)\n  print(x)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.9619334\n[1] -0.2925257\n[1] 0.2587882\n```\n:::\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.2587882\n```\n:::\n:::\n\n\n## Combining Loops and Conditional Evaluation\n\nConsider the following code. What do you think it does?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  if (i %% 2 == 1) {\n    print(\"odd\")\n  } else {\n    print(\"even\")\n  }\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"odd\"\n[1] \"even\"\n[1] \"odd\"\n[1] \"even\"\n[1] \"odd\"\n[1] \"even\"\n[1] \"odd\"\n[1] \"even\"\n[1] \"odd\"\n[1] \"even\"\n```\n:::\n:::\n\n\n## Fizz Buzz\n\n1.  Everyone takes turns to count incrementally.\n2.  Any number divisible by three is replaced with the word \"fizz.\"\n3.  Any number divisible by five is replaced with the word \"buzz.\"\n4.  Any number divisible by both three and five is replaced with the word \"fizzbuzz.\"\n\n## Fizz Buzz\n\nCan we write code for a computer to play fizz buzz with itself? Suppose we want the computer to play Fizz Buzz up to 100.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:100) {\n  if (i %% 3 == 0 & i %% 5 == 0) {\n    print(\"fizzbuzz\")\n  } else if (i %% 3 == 0) {\n    print(\"fizz\")\n  } else if (i %% 5 == 0) {\n    print(\"buzz\")\n  } else {\n    print(i)\n  }\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] \"fizz\"\n[1] 4\n[1] \"buzz\"\n[1] \"fizz\"\n[1] 7\n[1] 8\n[1] \"fizz\"\n[1] \"buzz\"\n[1] 11\n[1] \"fizz\"\n[1] 13\n[1] 14\n[1] \"fizzbuzz\"\n[1] 16\n[1] 17\n[1] \"fizz\"\n[1] 19\n[1] \"buzz\"\n[1] \"fizz\"\n[1] 22\n[1] 23\n[1] \"fizz\"\n[1] \"buzz\"\n[1] 26\n[1] \"fizz\"\n[1] 28\n[1] 29\n[1] \"fizzbuzz\"\n[1] 31\n[1] 32\n[1] \"fizz\"\n[1] 34\n[1] \"buzz\"\n[1] \"fizz\"\n[1] 37\n[1] 38\n[1] \"fizz\"\n[1] \"buzz\"\n[1] 41\n[1] \"fizz\"\n[1] 43\n[1] 44\n[1] \"fizzbuzz\"\n[1] 46\n[1] 47\n[1] \"fizz\"\n[1] 49\n[1] \"buzz\"\n[1] \"fizz\"\n[1] 52\n[1] 53\n[1] \"fizz\"\n[1] \"buzz\"\n[1] 56\n[1] \"fizz\"\n[1] 58\n[1] 59\n[1] \"fizzbuzz\"\n[1] 61\n[1] 62\n[1] \"fizz\"\n[1] 64\n[1] \"buzz\"\n[1] \"fizz\"\n[1] 67\n[1] 68\n[1] \"fizz\"\n[1] \"buzz\"\n[1] 71\n[1] \"fizz\"\n[1] 73\n[1] 74\n[1] \"fizzbuzz\"\n[1] 76\n[1] 77\n[1] \"fizz\"\n[1] 79\n[1] \"buzz\"\n[1] \"fizz\"\n[1] 82\n[1] 83\n[1] \"fizz\"\n[1] \"buzz\"\n[1] 86\n[1] \"fizz\"\n[1] 88\n[1] 89\n[1] \"fizzbuzz\"\n[1] 91\n[1] 92\n[1] \"fizz\"\n[1] 94\n[1] \"buzz\"\n[1] \"fizz\"\n[1] 97\n[1] 98\n[1] \"fizz\"\n[1] \"buzz\"\n```\n:::\n:::\n\n\n## Coding challenges\n\n-   Project Euler\n-   HackerRank\n-   LeetCode (doesn't support R)\n\n\n## Vectorization\n\nLast class, we saw how to use `for` and `while` loops to repeat tasks. However, often in R, functions or operations are vectorized, meaning they automatically act on every entry in a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nx * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 8\n```\n:::\n:::\n\n\n## Vectorization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\nx < 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE FALSE\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\ny <- 4:1\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5 5 5\n```\n:::\n:::\n\n\n## Vectorization with data\n\nWe often rely on vectorization when working with columns of a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\nlibrary(tidyverse)\ndata(penguins)\npenguins <- penguins |>\n  mutate(bill_len_dep_ratio = bill_length_mm / bill_depth_mm)\npenguins$bill_len_dep_ratio\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 2.090909 2.270115 2.238889       NA 1.901554 1.907767 2.185393 2.000000\n  [9] 1.883978 2.079208 2.210526 2.184971 2.335227 1.820755 1.639810 2.056180\n [17] 2.036842 2.053140 1.869565 2.139535 2.065574 2.016043 1.869792 2.110497\n [25] 2.255814 1.867725 2.182796 2.262570 2.037634 2.142857 2.365269 2.055249\n [33] 2.219101 2.164021 2.141176 1.857820 1.940000 2.281081 1.948187 2.083770\n [41] 2.027778 2.217391 1.945946 2.238579 2.189349 2.106383 2.163158 1.984127\n [49] 2.011173 1.995283 2.237288 2.121693 1.955307 2.153846 1.906077 2.225806\n [57] 2.228571 2.159574 2.198795 1.968586 2.112426 1.957346 2.211765 2.258242\n [65] 2.128655 2.311111 2.191358 2.151832 2.162651 2.154639 1.763158 2.157609\n [73] 2.302326 2.423280 2.028571 2.313514 2.434524 1.917526 2.248447 2.204188\n [81] 2.011628 2.437500 1.952128 1.809278 2.095506 2.034483 1.861538 1.983871\n [89] 1.994792 2.069149 1.983333 2.270718 1.988304 2.187845 2.092486 2.158730\n [97] 2.048387 2.178378 2.055901 2.335135 1.955307 2.050000 2.356250 1.890000\n[105] 2.037634 2.100529 2.244186 1.910000 2.241176 2.273684 2.309091 2.246305\n[113] 2.242938 2.164103 1.913043 2.333333 2.270588 1.819512 2.100000 2.209677\n[121] 2.104651 1.904040 2.364706 2.237838 2.213836 2.136842 2.204545 2.267760\n[129] 2.280702 2.450000 2.150838 2.244792 1.989189 2.027027 2.164773 2.348571\n[137] 2.034286 2.000000 2.242424 2.217877 2.350877 2.360465 2.070968 2.394118\n[145] 2.220238 2.085561 2.107527 1.989130 2.022472 2.088398 2.105263 2.243243\n[153] 3.492424 3.067485 3.453901 3.289474 3.282759 3.444444 3.109589 3.052288\n[161] 3.231343 3.038961 2.985401 3.043478 3.321168 3.315068 3.136986 3.140127\n[169] 3.111111 3.236842 3.186207 3.225166 3.510490 3.110345 3.206897 2.930380\n[177] 3.274809 3.052980 3.111888 3.186667 3.370629 3.267974 3.091503 3.014085\n[185] 3.110345 3.505882 3.317568 2.969325 3.109489 2.566474 3.235294 3.101911\n[193] 3.116788 3.100000 3.306569 3.306667 3.176101 3.136691 3.273381 3.176101\n[201] 3.375940 2.860759 3.281690 3.439716 3.131944 3.340000 3.229167 2.922078\n[209] 3.151079 3.033333 2.979310 3.294118 3.282609 3.100671 3.287770 3.458599\n[217] 3.225352 2.964286 3.208333 3.055556 3.063380 3.380000 3.180000 2.974359\n[225] 3.089744 3.141892 3.093333 3.037500 3.345070 3.134969 3.275362 2.756098\n[233] 3.386207 3.365385 3.246575 3.144654 3.253623 2.936416 3.013889 3.612676\n[241] 3.392857 3.064706 3.166667 3.052632 3.137931 3.074534 3.027211 3.235669\n[249] 3.126582 3.212329 3.361111 3.096970 3.233333 3.288235 3.045161 3.273333\n[257] 3.427536 2.906832 2.836735 3.379747 3.092857 3.185430 3.322368 3.132075\n[265] 2.861842 3.159509 3.276596 3.443750 2.834395 3.012346 3.445255       NA\n[273] 3.272727 3.210191 3.054054 3.099379 2.597765 2.564103 2.671875 2.427807\n[281] 2.661616 2.539326 2.532967 2.818681 2.433862 2.577889 2.617978 2.546798\n[289] 2.716763 2.872928 2.684211 2.576531 2.515000 3.258427 2.494624 2.703297\n[297] 2.450867 2.771429 2.602410 2.608247 2.608939 2.736842 2.744565 2.605263\n[305] 2.606742 2.640000 2.463855 2.605769 2.544910 2.712766 2.672043 2.827381\n[313] 2.601093 2.512077 2.825301 2.688442 2.512821 2.640000 2.664921 2.676471\n[321] 2.843575 2.745946 2.798883 2.500000 2.754011 2.878613 2.932927 2.705263\n[329] 2.641618 2.573604 2.456647 2.776596 2.722892 2.477387 2.670213 2.350515\n[337] 2.661538 2.836364 2.688235 2.818182 2.403315 2.725275 2.673684 2.684492\n```\n:::\n:::\n\n\n## Vectorization in functions\n\nOften we desire our function to be vectorized: so that it can take in vectors as inputs and perform an operation/task for each entry of the vector(s).\n\nFor this reason, it is important to begin remembering which functions are vectorized/vectorizable.\n\n## Absolute error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather_forecasts <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-12-20/weather_forecasts.csv')\nweather_forecasts <- weather_forecasts |>\n  mutate(abs_err_precip = abs(observed_temp - forecast_temp))\n```\n:::\n\n\n**Exercise**: Write a function that takes as input two vectors of length $n$, `observed` and `predicted` and returns a vector of length $n$ of the absolute errors.\n\n## Absolute error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabsolute_error <- function(observed, predicted) {\n  return(abs(observed - predicted))\n}\n```\n:::\n\n\n## Squared error\n\n**Exercise**: Write a function that takes as input two vectors of length $n$, `observed` and `predicted` and returns a vector of length $n$ of the squared errors.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquared_error <- function(observed, predicted) {\n  return((observed - predicted)^2)\n}\n```\n:::\n\n\n## Why not vectorize?\n\n-   modifying in place\n-   `while` loops\n-   recursive functions\n\n## Modifying in place\n\nSometimes we wish to change the value of some object iteratively. In such cases, vectorizing code may not be possible.\n\nWhat do you expect the output of this code to be?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nfor (i in 10:1) {\n  x[i] <- sum(x[1:i])\n}\nx\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  3  6 10 15 21 28 36 45 55\n```\n:::\n:::\n\n\n. . .\n\nThese are known as the triangular numbers.\n\n## Recursion\n\nRecursion is a method for solving a problem where the solution can be divided into simpler or smaller versions of the same problem.\n\n**Example**: Factorial function\n\n. . .\n\n**Example**: Fractals\n\n![](https://mathworld.wolfram.com/images/eps-svg/Fractal1_1000.svg){fig-align=\"center\"}\n\n## Recursive functions: factorial\n\nRecursive functions are those that call themselves to solve problems.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfact <- function(x) {\n  if (x == 0 | x == 1) {\n    return(1)\n  } else {\n    return(x * fact(x - 1))\n  }\n}\nfact(4)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 24\n```\n:::\n:::\n\n\n## Recursive functions: Fibonacci\n\nExercise: write a function `fibonacci()` that takes as input a natural number `n` and returns the $n$th Fibonacci number.\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfibonacci <- function(n) {\n  if (n == 1 | n == 2) {\n    return(1)\n  } else {\n    return(fibonacci(n - 1) + fibonacci(n - 2))\n  }\n}\nfibonacci(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55\n```\n:::\n:::\n\n\n## Recursive functions: Prime factorization\n\nWrite a function `factorize()` that takes as input a natural number `n` and returns its prime factorization.\n\n. . .\n\nHow might we get started with this question?\n\n",
    "supporting": [
      "13_functions-loops_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}