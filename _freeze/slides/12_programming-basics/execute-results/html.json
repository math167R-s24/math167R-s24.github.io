{
  "hash": "561ec8a57029b802be2c02baa8fcceff",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Programming Basics\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\nexecute:\n  echo: true\n  eval: true\n---\n\n\n## Overview of today\n\n-   What is an algorithm?\n-   Control statements\n-   Writing R functions\n\n## Programming and this class\n\nUp until now, we have been focusing on using R for exploratory data analysis:\n\n-   Downloading and combining datasets\n-   Objects and types of data in R\n-   Creating data visualizations and computing descriptive statistics\n-   Writing R Markdown documents for communication\n\nFor the next several weeks, we will focus on programming and computer science concepts (as they might be used for data science).\n\n## What is an algorithm?\n\nAn algorithm is a finite sequence of instructions for performing some task or solving some problem.\n\nAlgorithms should be unambiguous and precise. In other words, if the instructions are followed correctly, the output should be **reproducible**: using the same inputs twice should yield the same outputs each time.\n\n## A bad example: an ambiguous cookie recipe.\n\n1.  Mix dry ingredients.\n2.  Mix wet ingredients.\n3.  Add dry ingredients to wet ingredients.\n4.  Roll into balls and put on baking sheet.\n5.  Bake in oven.\n\n## A more precise example: the smallest number\n\n**Input**: A list of numbers L. **Output**: The smallest number in the list L\n\n1.  If L is empty, then there is no smallest number.\n2.  Assume the first number in L is the smallest.\n3.  For each remaining number in L, compare with the current assumed smallest number. If it is smaller, assume this number is now the smallest number.\n4.  When there are no more numbers in L to consider, report the current smallest number.\n\n## Flowcharts for algorithms\n\nYou may also find it helpful to imagine an algorithm as a flowchart (from Wikipedia):\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/LampFlowchart.svg/1024px-LampFlowchart.svg.png){fig-align=\"center\" width=\"300\"}\n\n## Algorithms in code\n\nSince algorithms are simply sets of instructions or \"recipes,\" we can represent them as:\n\n-   Written \"pseudo-code\" instructions (in English or other languages)\n-   Flow charts\n-   Code (in R, Python, or other programming languages)\n\nOur goal will be to write basic algorithms in R that we can use to carry out data science tasks.\n\n## Functions as algorithms\n\nEach function is an implementation of an algorithm. For example, consider the `rank()` function which returns the rank-ordering of each number in a vector:\n\n\n::: {.cell hash='12_programming-basics_cache/revealjs/unnamed-chunk-1_e51b53086bfe0cfc2ce182d5c4875095'}\n\n```{.r .cell-code}\nrank(c(10, 9, 8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 2 1\n```\n:::\n:::\n\n::: {.cell hash='12_programming-basics_cache/revealjs/unnamed-chunk-2_3f36ea56b0c204714d6f630f58d8f111'}\n\n```{.r .cell-code}\nrank\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, na.last = TRUE, ties.method = c(\"average\", \"first\", \n    \"last\", \"random\", \"max\", \"min\")) \n{\n    stopifnot(length(na.last) == 1L)\n    nas <- is.na(x)\n    nm <- names(x)\n    ties.method <- match.arg(ties.method)\n    if (is.factor(x)) \n        x <- as.integer(x)\n    x <- x[!nas]\n    y <- switch(ties.method, average = , min = , max = .Internal(rank(x, \n        length(x), ties.method)), first = sort.list(sort.list(x)), \n        last = sort.list(rev.default(sort.list(x, decreasing = TRUE))), \n        random = sort.list(order(x, stats::runif(sum(!nas)))))\n    if (!is.na(na.last) && any(nas)) {\n        yy <- NA\n        NAkeep <- (na.last == \"keep\")\n        if (NAkeep || na.last) {\n            yy[!nas] <- y\n            if (!NAkeep) \n                yy[nas] <- (length(y) + 1L):length(yy)\n        }\n        else {\n            len <- sum(nas)\n            yy[!nas] <- y + len\n            yy[nas] <- seq_len(len)\n        }\n        y <- yy\n        names(y) <- nm\n    }\n    else names(y) <- nm[!nas]\n    y\n}\n<bytecode: 0x13bcf1048>\n<environment: namespace:base>\n```\n:::\n:::\n\n\n## Exercise\n\nCan you write an algorithm to check if a positive integer N is divisible by 3?\n\n## Control statements\n\nMost algorithms will require the interpreter to check some conditions to determine the outcome.\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/LampFlowchart.svg/1024px-LampFlowchart.svg.png){fig-align=\"center\" width=\"250\"}\n\nBy default, the expressions in the body of a function are evaluated sequentially.\n\nIn programming, control statements allow the developer (the person writing the code) to tell the interpreter what to do in different scenarios.\n\n## `if` statements\n\nR provides the `if` syntax for conditional evaluation:\n\n`if (condition) code`\n\n-   `if` statements give conditions for which a chunk of code is evaluated.\n\n-   First, a condition is specified before a chunk of code.\n\n    -   If the condition is `TRUE`, then the chunk is evaluated.\n    -   If the condition is `FALSE`, then it is not evaluated.\n\n## `if` statements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\n# Conditions go in parentheses after if\nif (x > 0) {\n  # code chunks get surrounded by curly brackets\n  print(paste0(\"x is equal to \", x, \", a positive number!\"))\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is equal to 1, a positive number!\"\n```\n:::\n:::\n\n\n## `if` statements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -1\n# Conditions go in parenthesis after if\nif (x > 0) {\n  # code chunks get surrounded by curly brackets\n  print(paste0(\"x is equal to \", x, \", a positive number!\"))\n}\n```\n:::\n\n\n## `if` statements\n\nWe can also write one line `if` statements without braces:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- NULL\nscore <- 65\nif (score >= 60) grade <- \"CR\"\nprint(grade)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"CR\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- NULL\nscore <- 55\nif (score >= 60) grade <- \"CR\"\nprint(grade)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\n## `else` statements\n\nWe can use `else` to specify what we want to happen when the condition is `FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\nif (x > 0) {\n  print(paste0(\"x is equal to \", x, \", a positive number!\"))\n} else {\n  print(paste0(\"x is equal to \", x, \", a negative number!\"))\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is equal to 1, a positive number!\"\n```\n:::\n:::\n\n\n## `else` statements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -1\nif (x > 0) {\n  print(paste0(\"x is equal to \", x, \", a positive number!\"))\n} else {\n  print(paste0(\"x is equal to \", x, \", a negative number!\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is equal to -1, a negative number!\"\n```\n:::\n:::\n\n\n## `else if`\n\nWe use `else if` when there are more than two possible paths. Here, the final `else` chunk will evaluate for any cases not covered by the `if` or `else if`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\nif (x > 0) {\n  paste0(\"x is equal to \", x, \", a positive number!\")\n} else if (x < 0) {\n  paste0(\"x is equal to \", x, \", a negative number!\")\n} else {\n  paste0(\"x is equal to \", x, \"!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is equal to 1, a positive number!\"\n```\n:::\n:::\n\n\n## `else if`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -1\nif (x > 0) {\n  paste0(\"x is equal to \", x, \", a positive number!\")\n} else if (x < 0) {\n  paste0(\"x is equal to \", x, \", a negative number!\")\n} else {\n  paste0(\"x is equal to \", x, \"!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is equal to -1, a negative number!\"\n```\n:::\n:::\n\n\n## `else if`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nif (x > 0) {\n  paste0(\"x is equal to \", x, \", a positive number!\")\n} else if (x < 0) {\n  paste0(\"x is equal to \", x, \", a negative number!\")\n} else {\n  paste0(\"x is equal to \", x, \"!\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"x is equal to 0!\"\n```\n:::\n:::\n\n\n# Control Statements: Examples\n\n## Divisibility\n\nSuppose we want to check if `x` is divisible by 3 and print out the answer. What should `CONDITION` be?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\nif (CONDITION) {\n  IF TRUE, DO THIS\n} else {\n  ELSE, DO THIS\n}\n```\n:::\n\n\n## Divisibility\n\nSuppose we want to check if `x` is divisible by 5 and print out the answer. What should `CONDITION` be?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\n# modulo operator\nif (x %% 3 == 0) {\n  print(\"divisible by 3\")\n} else {\n  print(\"not divisible by 3\")\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"not divisible by 3\"\n```\n:::\n:::\n\n\n## Check length of strings\n\nNote: We will need the `stringr` package for this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run this if you have never installed stringr before!\n# install.packages(\"stringr\")\nlibrary(stringr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"cat\"\nif (str_length(x) <= 10) {\n  cat(\"x is a short string.\")\n} else {\n  cat(\"x is a long string.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is a short string.\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"A big fluffy cat with orange fur and stripes\"\nif (str_length(x) <= 10) {\n  cat(\"x is a short string.\")\n} else {\n  cat(\"x is a long string.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is a long string.\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Check class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5\nif (is.numeric(x)) {\n  cat(\"x is a numeric.\")\n} else if (is.character(x)) {\n  cat(\"x is a character.\")\n} else {\n  cat(\"x is some class I didn't check for in my code.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is a numeric.\n```\n:::\n:::\n\n\n## Check class\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list()\nif (is.numeric(x)) {\n  cat(\"x is a numeric.\")\n} else if (is.character(x)) {\n  cat(\"x is a character.\")\n} else {\n  cat(\"x is some class I didn't check for in my code.\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx is some class I didn't check for in my code.\n```\n:::\n:::\n\n\n## Exercise\n\nWrite code that, given two numerics `x` and `y`, prints out:\n\n* `EQUAL` if `sum(x)` and `sum(y)` are equal.\n* `X` if `sum(x)` is bigger.\n* `Y` if `sum(y)` is bigger.\n\n## Functions\n\nWe've already seen and used several functions, but you can also create your own.\n\nThis is incredibly useful when:\n\n-   You use the same code repeatedly\n-   You want to perform the same task for slightly different input values\n-   You want others to be able to use your code\n\n## Anatomy of a function\n\nThe function named `function` is used to create a function:\n\n`function(formal arguments) {body}`\n\nThe body comprises one or more lines of code that will perform the desired computations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncelsiusToFahrenheit <- function(x) {x * 9 / 5 + 32}\ncelsiusToFahrenheit(0)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 32\n```\n:::\n:::\n\n\n## Anatomy of a function\n\nFor more complicated functions, we typically move the body to a new line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name <- function(param1, param2 = \"default\") {\n  # body of the function\n  return(output)\n}\n```\n:::\n\n\n-   `function_name`: the name you want to give your function, what you will use to call it\n-   `function()`: call this to define a function\n-   `param1`, `param2`: formal arguments input by the user. You can assign default values by setting them equal to something in the call to `function()`\n-   **body**: the actual code that is executed\n-   `return()`: the output value **returned** to the user\n\n## Square a number, add 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare_plus_2 <- function(x) {\n  y <- x^2 + 2\n  return(y)\n}\n\nsquare_plus_2(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18\n```\n:::\n\n```{.r .cell-code}\nsquare_plus_2(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 102\n```\n:::\n\n```{.r .cell-code}\nsquare_plus_2(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  6 11 18 27\n```\n:::\n:::\n\n\n## Square a number, add 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare_plus_2(\"some string\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in x^2: non-numeric argument to binary operator\n```\n:::\n:::\n\n\nWhat happened here?\n\n. . .\n\nWe wrote a function for numerics only but didn't check the input.\n\n## Square a number, add 2\n\nLet's try making our function more robust by adding a `if` statement and a `stop` call.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare_plus_2 <- function(x) {\n  if (!is.numeric(x)) {\n    stop(\"x must be numeric!\")\n  } else {\n    y <- x^2 + 2\n    return(y)\n  }\n}\n\nsquare_plus_2(\"some string\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in square_plus_2(\"some string\"): x must be numeric!\n```\n:::\n:::\n\n\n# Style Guide\n\n## Function Names\n\nStrive to have function names based on verbs. Otherwise, standard variable name style guidelines apply!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nadd_row()\npermute()\n\n# Bad\nrow_adder()\npermutation()\n```\n:::\n\n\n## Spacing\n\nPlace a space before and after `()` when used with `if`, `for`, or `while`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nif (condition) {\n  x + 2\n}\n\n# Bad\nif(condition){\n  x + 2\n}\n```\n:::\n\n\n## Spacing\n\nPlace a space after `()` used for function arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nif (debug) {\n  show(x)\n}\n\n# Bad\nif(debug){\n  show(x)\n}\n```\n:::\n\n\n## Code Blocks\n\n-   `{` should be the last character on the line. Related code (e.g., an `if` clause, a function declaration, a trailing comma, ...) must be on the same line as the opening brace. It should be preceded by a single space.\n-   The contents within code blocks should be indented by two spaces from where it started\n-   `}` should be the first character on the line.\n\n## Code Blocks\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nif (y < 0) {\n  message(\"y is negative\")\n}\n\nif (y == 0) {\n  if (x > 0) {\n    log(x)\n  } else {\n    message(\"x is negative or zero\")\n  }\n} else {\n  y^x\n}\n```\n:::\n\n\n## Code Blocks\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bad\nif (y<0){\nmessage(\"Y is negative\")\n}\n\nif (y == 0)\n{\n    if (x > 0) {\n      log(x)\n    } else {\n  message(\"x is negative or zero\")\n    }\n} else { y ^ x }\n```\n:::\n\n\n## In-line Statements\n\nIn general, it's ok to drop the curly braces for very simple statements that fit on one line. However, function calls that affect control flow (`return`, `stop`, etc.) should always go in their own `{}` block:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\ny <- 10\nx <- if (y < 20) \"Too low\" else \"Too high\"\n\nif (y < 0) {\n  stop(\"Y is negative\")\n}\n\nfind_abs <- function(x) {\n  if (x > 0) {\n    return(x)\n  }\n  x * -1\n}\n```\n:::\n\n\n## In-line Statements\n\nIn general, it's ok to drop the curly braces for very simple statements that fit on one line. However, function calls that affect control flow (`return`, `stop`, etc.) should always go in their own `{}` block:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bad\nif (y < 0) stop(\"Y is negative\")\n\nif (y < 0)\n  stop(\"Y is negative\")\n\nfind_abs <- function(x) {\n  if (x > 0) return(x)\n  x * -1\n}\n```\n:::\n\n\n## Long lines in functions\n\nIf a function definition runs over multiple lines, indent the second line to where the definition starts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nlong_function_name <- function(a = \"a long argument\",\n                               b = \"another argument\",\n                               c = \"another long argument\") {\n  # As usual code is indented by two spaces.\n}\n\n# Bad\nlong_function_name <- function(a = \"a long argument\",\n  b = \"another argument\",\n  c = \"another long argument\") {\n  # Here it's hard to spot where the definition ends and the\n  # code begins\n}\n```\n:::\n\n\n## `return`\n\nStrictly speaking, `return` is not necessary in a function definition. The function will output the last line of executable R code. The following function definitions will output the same results!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAdd_Values <- function(x, y) {\n  return(x + y)\n}\n\nAdd_Values <- function(x, y) {\n  x + y\n}\n```\n:::\n\n\n## Commenting functions\n\nFor now, when commenting functions, include (at least) 3 lines of comments:\n\n-   a comment describing the purpose of a function\n-   a comment describing each input\n-   a comment describing the output\n\nThe function body should be commented as usual!\n\n## Commenting functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good ----\n# Function: square_plus_2, squares a number and then adds 2\n# Input: x, must be numeric\n# Output: numeric equal to x^2 + 2\nsquare_plus_2 <- function(x) {\n  # check that x is numeric\n  if (!is.numeric(x)) {\n    stop(\"x must be numeric!\")\n  } else {\n    # if numeric, then square and add 2\n    y <- x^2 + 2\n    return(y)\n  }\n}\n```\n:::\n\n\n## Commenting functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bad ----\n# Function for problem 2c\nsquare_plus_2 <- function(x) {\n  if (!is.numeric(x)) {\n    stop(\"x must be numeric!\")\n  } else {\n    y <- x^2 + 2\n    return(y)\n  }\n}\n```\n:::\n\n\n## Exercises\n\n1.  Write a function that takes as input three numbers, `a`, `b`, and `c`, and returns the sum, **without using the `sum` function**.\n2.  Write a function that takes as input one number, `a`, and returns its absolute value, **without using the `abs` function**.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}