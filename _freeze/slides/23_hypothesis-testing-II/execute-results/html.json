{
  "hash": "b04c44b4a1e3295e1c97d94d841b791d",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Hypothesis Testing\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\n---\n\n\n## Overview of today\n\n-   Review of basic hypothesis tests\n-   Permutation tests\n-   Simulations for power analysis\n-   P-hacking simulations\n\n## Summary: hypothesis testing\n\n1.  Define null and alternative hypotheses.\n\n    -   ex. $H_0:\\mu = 0$ and $H_a:\\mu\\neq 0$\n\n2.  Compute a test statistic for which the null sampling distribution is known (based on assumptions about the population/sample).\n\n    -   ex. $T=(\\overline{X}_n-\\mu)/(S^2/\\sqrt{n})\\sim t_{n-1}$\n\n3.  Compare the test statistic with the null distribution to obtain a P-value.\n\n    -   ex. $P(|T|>|t|)$ where $t$ is the observed test statistic.\n\n## Example: Two-sample $z$-test\n\n**Assumptions**:\n\n1.  $X_1, \\ldots, X_m$ is a random sample from a distribution with mean $\\mu_1$ and variance $\\sigma_1^2$.\n2.  $Y_1, \\ldots, Y_n$ is a random sample from a distribution with mean $\\mu_2$ and variance $\\sigma_2^2$.\n3.  The $X$ and $Y$ samples are independent of one another.\n4.  The sample sizes are adequately large (usually appropriate if $m>40$ and $n>40$.\n\n\n## Example: Two-sample $z$-test\n\n\n**Hypotheses**:\n\n-   H_0: $\\mu_1=\\mu_2$\n-   H_a: $\\mu_1\\not=\\mu_2$\n\n## Example: Two-sample $z$-test\n\nUnder these assumptions, $\\overline{X}-\\overline{Y}$ is approximately normal and the test statistic $$Z=\\frac{\\overline{X}-\\overline{Y}-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{S_1^2}{m}+\\frac{S_2^2}{n}}}$$ has approximately a standard normal distribution when $H_0$ is true.\n\n## Example: Two-sample $t$-test\n\nWhen the samples are small, but the population distributions are approximately normal, the standardized test statistic $$T=\\frac{\\overline{X}-\\overline{Y}-(\\mu_1-\\mu_2)}{\\sqrt{\\frac{S_1^2}{m}+\\frac{S_2^2}{n}}}$$ has approximately a $t$ distribution with df $v$ estimated from the data by\n\n$$\\nu =\\frac{\\left(\\frac{s_1^2}{m}+\\frac{s_2^2}{n}\\right)^2}{\\frac{(s_1^2/m)^2}{m-1}+\\frac{(s_2^2/n)^2}{n-1}}$$\n\n## Example: Two-sample $t$-test\n\nWe can use the `sleep` data in R, which contains Student's example data on the effect of two sleeping drugs on 10 patients, to test out the `t.test()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(extra ~ group, data = sleep)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tWelch Two Sample t-test\n\ndata:  extra by group\nt = -1.8608, df = 17.776, p-value = 0.07939\nalternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0\n95 percent confidence interval:\n -3.3654832  0.2054832\nsample estimates:\nmean in group 1 mean in group 2 \n           0.75            2.33 \n```\n:::\n:::\n\n\n## Permutation tests\n\nTypically, for hypothesis testing, we need to know the sampling distribution of the test statistic when the null hypothesis is true.\n\nIn some cases, we can derive the null sampling distribution analytically.\n\n**What if we don't know the sampling distribution under the null?** A permutation test is simple way to estimate the sampling distribution for any test statistic, requiring only some exchangeability assumptions on the data.\n\n## Permutation tests\n\n**Example:** Suppose we want to understand whether carrying a particular genetic variant affects an individual's height $y$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarrier <- rep(c(0,1), c(100,200))\n\n# an example where y is independent of the gene\nnull_y <- rnorm(300) \n# an example where y is dependent on the gene\nalt_y <- rnorm(300, mean = carrier * 5) \n```\n:::\n\n\n## Permutation tests\n\nIf the null hypothesis is true, the distribution of $Y$ for the carriers should look the same as the distribution for the non-carriers. If we **permute** the labels repeatedly, we can get resampled datasets.\n\nIf the null hypothesis is true, the shuffled data sets will resemble the original dataset. If the null hypothesis is false, the shuffled dataset may not look like the real data.\n\n## Null hypothesis true\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n## Null hypothesis false\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n\n## Permutation tests\n\n1.  Calculate a test statistic based on the observed data.\n2.  Repeatedly permute the group labels to create resamples. For each resample, compute the resample test statistic.\n3.  Compare the observed data test statistic with the distribution of resampled test statistics.\n\n## Permutation tests\n\nIn the case of our simulated data, we know the true distribution of the difference of sample means. We can thus use a $t$-test to perform our hypothesis test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(null_y[carrier == 0], null_y[carrier == 1], var.equal=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tTwo Sample t-test\n\ndata:  null_y[carrier == 0] and null_y[carrier == 1]\nt = -0.20376, df = 298, p-value = 0.8387\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -0.2703315  0.2196040\nsample estimates:\n mean of x  mean of y \n0.08703446 0.11239820 \n```\n:::\n:::\n\n\n## Permutation tests\n\nCompare with the $t$-test for the alternative hypothesis data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt.test(alt_y[carrier == 0], alt_y[carrier == 1], var.equal=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tTwo Sample t-test\n\ndata:  alt_y[carrier == 0] and alt_y[carrier == 1]\nt = -42.775, df = 298, p-value < 2.2e-16\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -5.360905 -4.889319\nsample estimates:\n mean of x  mean of y \n0.01365367 5.13876563 \n```\n:::\n:::\n\n\n## Permutation tests\n\nFor now, though, let's pretend we don't know the true null sampling distribution of our test statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nnull_diff <- mean(null_y[carrier==1]) - mean(null_y[carrier==0])\nsingle_test <- function(label, y) {\n  resample <- sample(label)\n  # resample test statistic\n  mean(y[resample == 1]) - mean(y[resample == 0])\n}\ntest_stats_null <- replicate(1000, single_test(carrier, null_y))\n```\n:::\n\n\n## Permutation tests\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(test_stats_null)\nabline(v = null_diff, lwd=2, col=\"purple\")\n```\n\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n\n```{.r .cell-code}\nmean(abs(test_stats_null) > abs(null_diff)) # P-value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.828\n```\n:::\n:::\n\n\n## Permutation tests\n\nCompare with the case where the null hypothesis is false.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\nalt_diff <- mean(alt_y[carrier==1]) - mean(alt_y[carrier==0])\ntest_stats_alt <- replicate(1000, single_test(carrier, alt_y))\nhist(test_stats_alt, xlim = c(-0.5, 6))\nabline(v = alt_diff, lwd=2, col=\"purple\")\n```\n\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/unnamed-chunk-9-1.png){width=960}\n:::\n\n```{.r .cell-code}\nmean(abs(test_stats_alt) > abs(alt_diff)) # P-value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n## Power analysis\n\nRecall that the power of a hypothesis test is the probability of rejecting the null hypothesis when the null hypothesis is false.\n\nNote the power will depend on the size of the difference between the true sampling distribution and the null hypothesis sampling distribution.\n\n## One sample $z$-test\n\nSuppose that $X_1,\\ldots, X_n\\sim N(\\mu, 1)$.\n\nConsider the hypotheses $H_0:\\mu=0$ and $H_a:\\mu\\neq 0$.\n\nWe reject at the $\\alpha$ significance level if $$|\\overline{X}_n| > \\frac{z_{\\alpha/2}}{\\sqrt{n}}$$\n\nIf $\\mu=\\mu_a\\neq 0$, then $$\\overline{X}_n\\sim N\\left(\\mu_a, \\frac{1}{\\sqrt{n}}\\right)$$\n\n## One sample $z$-test\n\n$$\n\\begin{align}\nP\\left(|\\overline{X}_n| > \\frac{z_{\\alpha/2}}{\\sqrt{n}}\\right)&=P\\left(\\overline{X}_n> \\frac{z_{\\alpha/2}}{\\sqrt{n}}\\right) + P\\left(\\overline{X}_n < -\\frac{z_{\\alpha/2}}{\\sqrt{n}}\\right)\\\\\n&=P\\left(\\frac{\\overline{X}_n-\\mu_a}{1/\\sqrt{n}}> z_{\\alpha/2}-\\frac{\\mu_a}{1/\\sqrt{n}}\\right) \\\\\n&+ P\\left(\\frac{\\overline{X}_n-\\mu_a}{1/\\sqrt{n}}<-z_{\\alpha/2}-\\frac{\\mu_a}{1/\\sqrt{n}}\\right)\\\\\n&=\\left(1-\\Phi\\left(z_{\\alpha/2}-\\frac{\\mu_a}{1/\\sqrt{n}}\\right)\\right)+\\Phi\\left(-z_{\\alpha/2}-\\frac{\\mu_a}{1/\\sqrt{n}}\\right)\n\\end{align}\n$$\n\n## One sample $z$-test\n\n\n::: {.cell}\n\n```{.r .cell-code}\none_sample_z_power <- function(mu_a, alpha, n) {\n  z <- qnorm(1 - alpha / 2)\n  return(1 - pnorm(z - mu_a * sqrt(n)) + pnorm(-z - mu_a * sqrt(n)))\n}\n\n# plot the power function\nx <- data.frame(x = seq(-3, 3, length.out = 1000))\nggplot(x, aes(x = x)) + \n  geom_function(fun = one_sample_z_power, \n                aes(color = \"n = 5\"),\n                args = list(alpha = .05, n = 5)) +\n  geom_function(fun = one_sample_z_power, \n                aes(color = \"n = 10\"),\n                args = list(alpha = .05, n = 10)) +\n  geom_function(fun = one_sample_z_power, \n                aes(color = \"n = 20\"),\n                args = list(alpha = .05, n = 20)) +\n  xlab(\"True population mean\") + ylab(\"Power\") +\n  theme_bw()\n```\n:::\n\n\n## One sample $z$-test\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n## Using simulations to estimate power\n\n\n::: {.cell hash='23_hypothesis-testing-II_cache/revealjs/power.sim_a981c6598dee417e5db45c067ecc14fd'}\n\n```{.r .cell-code}\nsimulate_test <- function(mu_a, alpha, n) {\n  Xbar <- mean(rnorm(n, mean = mu_a, sd = 1))\n  Z_score <- Xbar * sqrt(n)\n  return(abs(Z_score) > qnorm(1 - alpha / 2))\n}\npower_sim <- function(mu_a, alpha, n) {\n  return(mean(replicate(1000, simulate_test(mu_a, alpha, n))))\n}\n\nmu_a <- data.frame(mu_a = seq(-2.5, 2.5, length.out = 100))\nsample_sizes <- c(5, 10, 20)\n\n# matrix of simulation results\nsim_results <- \n  sapply(sample_sizes,\n         function(n) \n           sapply(mu_a$mu_a, \n                  function(mu)\n                    power_sim(mu, .05, n)))\n\nggplot(mu_a, aes(x = mu_a)) +\n  geom_line(aes(y = sim_results[, 1], color = \"n = 5\")) +\n  geom_line(aes(y = sim_results[, 2], color = \"n = 10\")) +\n  geom_line(aes(y = sim_results[, 3], color = \"n = 20\")) +\n  xlab(\"True population mean\") + ylab(\"Power\") +\n  theme_bw()\n```\n:::\n\n\n## Using simulations to estimate power\n\n\n::: {.cell hash='23_hypothesis-testing-II_cache/revealjs/power.sim.eval_aeacd82b6447f630ab197645a003056b'}\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/power.sim.eval-1.png){width=960}\n:::\n:::\n\n\n## P-hacking simulations\n\n**P-hacking** refers to the practice of repeatedly performing hypothesis tests (and potentially manipulating the data) until a statistically significant P-values is obtained. Usually, only this final result is published, without mentioning all of the manipulations that came before.\n\n## P-hacking simulations\n\nSuppose we simulate 25 observations of 8 variables which we know to be uncorrelated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nno_signal_data <- matrix(rnorm(200), ncol = 8) # 25 x 8 matrix\npairs(no_signal_data) # pairwise scatter plots\n```\n\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/phack.sim-1.png){width=960}\n:::\n:::\n\n\n## P-hacking simulations\n\n\n::: {.cell hash='23_hypothesis-testing-II_cache/revealjs/phack.sim.eval_61abaf51a533afd3c2c788587e68fed6'}\n\n```{.r .cell-code}\nno_signal_data <- matrix(rnorm(200), ncol = 8) # 25 x 8 matrix\npairs(no_signal_data) # pairwise scatter plots\n```\n\n::: {.cell-output-display}\n![](23_hypothesis-testing-II_files/figure-revealjs/phack.sim.eval-1.png){width=960}\n:::\n:::\n\n\n## Multiple testing simulations\n\nWhat if we perform a hypothesis test to test whether the correlation is zero between each pair of variables using `cor.test()`? With only 8 variables, we have 28 potential comparisons, the probability that we will (falsely) reject the null is already:\n\n\n::: {.cell hash='23_hypothesis-testing-II_cache/revealjs/comp_cfd29a198fa43e90595d54d0f43e24b4'}\n\n```{.r .cell-code}\n1 - (0.95) ^ 28\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7621731\n```\n:::\n:::\n\n\n## Multiple testing simulations\n\n\n::: {.cell hash='23_hypothesis-testing-II_cache/revealjs/phack.sim.p_18ed59b73fc0003f4ac6a9e6308437f7'}\n\n```{.r .cell-code}\nset.seed(1029)\nno_signal_data<- matrix(rnorm(200), ncol = 8) # 25 x 8 matrix\npairs_to_compare <- combn(8, 2) # all combinations of 2 numbers from 1-8\np_values <- c()\nfor (i in 1:ncol(pairs_to_compare)) {\n  index_1 <- pairs_to_compare[1, i]\n  index_2 <- pairs_to_compare[2, i]\n  test_res <- \n    cor.test(no_signal_data[, index_1],\n             no_signal_data[, index_2])\n  p_values <- c(p_values, test_res$p.value)\n}\nprint(min(p_values))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.006656272\n```\n:::\n:::\n\n\n## Multiple testing simulations\n\nFor this reason it is common to perform a correction to the p-values when many hypothesis tests are conducted.\n\n**Example**: The Bonferroni correction divides $\\alpha$ by the number of tests performed to get the corrected significance level.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}