{
  "hash": "8f833b7202b30f5cae35996ac3bc2083",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Vectorized functions and lists\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\n---\n\n\n## Warm-up\n\nDiscuss the following lines of code. What do they do?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3 > 4, T, 5 > 6)\ny <- c(1, 0, 1)\nrbind(x, y)\n```\n:::\n\n\n. . .\n\n**Answer:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3 > 4, T, 5 > 6)\ny <- c(1, 0, 1)\nrbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1] [,2] [,3]\nx    0    1    0\ny    1    0    1\n```\n:::\n:::\n\n\n## Overview of today\n\n-   Vectorized functions\n-   Lists\n-   Data frames\n\n# Vectorized functions\n\n## Vector Arithmetic\n\n**Vectorization**: applying a function repeatedly to every entry in a vector/array\n\nVectorization allows us to quickly carry out computations for every individual in a dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:5\ny <- -1:-5\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1 -2 -3 -4 -5\n```\n:::\n\n```{.r .cell-code}\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0 0 0 0\n```\n:::\n\n```{.r .cell-code}\nx * y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  -1  -4  -9 -16 -25\n```\n:::\n:::\n\n\n## Vector Arithmetic\n\nNote that R **recycles**, repeating elements of shorter vectors to match longer vectors. This is incredibly useful when done on purpose, but can also easily lead to hard-to-catch bugs in your code!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 * x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n\n```{.r .cell-code}\nc(1, -1) * x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 -2  3 -4  5\n```\n:::\n\n```{.r .cell-code}\nc(1, -1) + x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1 4 3 6\n```\n:::\n:::\n\n\n## Vector Arithmetic\n\nWe can apply many functions component-wise to vectors, including comparison operators.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx >= 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\ny < -2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\n(x >= 3) & (y < -2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\nx == c(1, 3, 2, 4, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE  TRUE  TRUE\n```\n:::\n:::\n\n\n## Boolean Vectors\n\nIn code, entries that are `TRUE` or `FALSE` are called **booleans** (logicals in R). These are incredibly important, because they can be used to give your computer conditions. What will the following code do?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[x > 3] <- 3\nx\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 3 3\n```\n:::\n:::\n\n\n## Boolean Vectors\n\nWe can also do basic arithmetic with booleans. `TRUE` is encoded as `1` and `FALSE` is encoded as `0`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# First reset x\nx <- 1:5\nsum(x >= 3)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x >= 3)\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.6\n```\n:::\n:::\n\n\n. . .\n\nWhat is this last quantity telling us?\n\n. . .\n\nBy taking the mean, we are looking at the **proportion** of our vector that is `TRUE`.\n\n## Complicated indexing\n\nWe can also get more complicated with our indexing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Return the second and third elements of \ny[c(2, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2 -3\n```\n:::\n\n```{.r .cell-code}\n# Return the values of x greater than 3\nx[x >= 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n:::\n\n\n## Complicated indexing\n\nWe can also get more complicated with our indexing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Values of x that match the index of the values of y that are less than -2\nx[y < -2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n\n```{.r .cell-code}\n# which() returns the index of entries that are TRUE\nwhich(y < -2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5\n```\n:::\n:::\n\n\n## Complicated indexing\n\nWe can compare entire vectors using `identical()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(x, -rev(y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nWhat do you think the function `rev()` is doing in the code above?\n\n*Hint:* Use `?rev` to read the help files for the function\n\n# Lists\n\n## Lists\n\n**Lists**, like vectors and matrices, are a class of objects in R. Lists are special because they can store multiple different types of data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list <- list(\"some_numbers\" = 1:5,\n                \"some_characters\" = c(\"a\", \"b\", \"c\"),\n                \"a_matrix\" = diag(2))\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$some_numbers\n[1] 1 2 3 4 5\n\n$some_characters\n[1] \"a\" \"b\" \"c\"\n\n$a_matrix\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n:::\n\n\nMake sure to store items within a list using the `=` operator for assigning arguments, not the assignment arrow `<-`\n\n## Accessing List Elements\n\nThere are three ways to access an item within a list\n\n-   double brackets `[[]]` with its name in quotes\n-   double brackets `[[]]` with its index as a number\n-   dollar sign `$` followed by its name without quotes\n\n## Accessing List Elements\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[[\"some_numbers\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nmy_list$some_numbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n## Why double brackets?\n\nIf you use a single bracket to index, like we do with matrices and vectors, you will return a **list** with a single element.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$some_numbers\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nmy_list[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nNote that this means you can only return a single item in a list using double brackets or the dollar sign! (Why?)\n\n## Why double brackets?\n\nThis is a subtle but important difference!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[1] + 1\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in my_list[1] + 1: non-numeric argument to binary operator\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[[1]] + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5 6\n```\n:::\n:::\n\n\n## Subsetting a list\n\nYou can subset a list similarly to vectors and matrices using single brackets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list[1:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$some_numbers\n[1] 1 2 3 4 5\n\n$some_characters\n[1] \"a\" \"b\" \"c\"\n```\n:::\n\n```{.r .cell-code}\nmy_list[-2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$some_numbers\n[1] 1 2 3 4 5\n\n$a_matrix\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n:::\n\n\n## Adding to a list {.smaller}\n\nWe can use the same tools we used to access list elements to add to a list. However, if we use double brackets, we must use quotes, otherwise R will search for something that does not yet exist.\n\n## Adding to a list {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_list$a_boolean <- FALSE\nmy_list[[\"a_list\"]] <- list(\"recursive\" = TRUE)\nmy_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$some_numbers\n[1] 1 2 3 4 5\n\n$some_characters\n[1] \"a\" \"b\" \"c\"\n\n$a_matrix\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\n$a_boolean\n[1] FALSE\n\n$a_list\n$a_list$recursive\n[1] TRUE\n```\n:::\n:::\n\n\n## Names of List Items\n\nCall `names()` to get a vector of list item names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(my_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"some_numbers\"    \"some_characters\" \"a_matrix\"        \"a_boolean\"      \n[5] \"a_list\"         \n```\n:::\n:::\n\n\n## Why bother?\n\n-   Lists give us **key-value pairs**, also known as **dictionaries** or **associative arrays**\n-   This means we can look up items in a list by name, rather than location\n-   For example, if we know we are looking for `output` within a list, we can always search for it, regardless of how the list was created or what else it contains\n\n# Data Frames\n\n## Data frames\n\nA **data frame** in R is essentially a special type of list, where each item is a vector of equal length. Typically, we say that data has $n$ rows (one for each **observation**) and $p$ columns (one for each **variable**)\n\nUnlike a matrix, columns can have different types. However, many column functions still apply! (such as `colSums`, `summary`, etc.)\n\n## Example data frames in R {.smaller}\n\nThere are plenty of free datasets available through R and its packages. If you haven't already, run `install.packages(\"palmerpenguins\")` in your console. Then, we can load the `penguins` dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load palmer penguins package\nlibrary(palmerpenguins)\n\n# open penguins data as a data frame\ndata(penguins)\npenguins <- as.data.frame(penguins)\n```\n:::\n\n\n## Penguins data {.smaller}\n\nWe can use the `head` function to look at the first several rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  species    island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g\n1  Adelie Torgersen           39.1          18.7               181        3750\n2  Adelie Torgersen           39.5          17.4               186        3800\n3  Adelie Torgersen           40.3          18.0               195        3250\n4  Adelie Torgersen             NA            NA                NA          NA\n5  Adelie Torgersen           36.7          19.3               193        3450\n6  Adelie Torgersen           39.3          20.6               190        3650\n     sex year\n1   male 2007\n2 female 2007\n3 female 2007\n4   <NA> 2007\n5 female 2007\n6   male 2007\n```\n:::\n:::\n\n\n-   How many columns are in this dataset?\n-   How many rows are in this dataset?\n\n## Penguins data {.smaller}\n\nUsing the `$` operator, we can access individual columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(penguins$bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 39.1 39.5 40.3   NA 36.7 39.3\n```\n:::\n:::\n\n\nWe can then use any of our useful functions for vectors to summarize this column (ex. `max()`, `min()`, `mean()`, `median()`, `sum()`, `sd()`, `var()`, `length()`).\n\n## Penguins data {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(penguins$bill_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n. . .\n\nNote that we may have to drop missing values, using the argument `na.rm = T`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(penguins$bill_length_mm, na.rm = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 43.92193\n```\n:::\n:::\n\n\n## Creating a data frame\n\nAn easy way to create a data frame is to use the function `data.frame()`.\n\nLike lists, make sure you define the names using `=` and not `<-`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data <- data.frame(\"var1\" = 1:3,\n                      \"var2\" = c(\"a\", \"b\", \"c\"),\n                      \"var3\" = c(TRUE, FALSE, TRUE))\nmy_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1 var2  var3\n1    1    a  TRUE\n2    2    b FALSE\n3    3    c  TRUE\n```\n:::\n:::\n\n\n## Creating a data frame\n\nIf you import or create numeric data as a `matrix`, you can also convert it easily using `as.data.frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix <- matrix(1:9, nrow = 3, ncol = 3)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\nas.data.frame(my_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  V1 V2 V3\n1  1  4  7\n2  2  5  8\n3  3  6  9\n```\n:::\n:::\n\n\n## Subsetting data frames\n\nWe can subset data frames using most of the tools we've learned about subsetting so far. We can use keys or indices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data$var1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmy_data[\"var1\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1\n1    1\n2    2\n3    3\n```\n:::\n\n```{.r .cell-code}\nmy_data[[\"var1\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n:::\n\n\n## Subsetting data frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1\n1    1\n2    2\n3    3\n```\n:::\n\n```{.r .cell-code}\nmy_data[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmy_data[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\nmy_data[1, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1 var2 var3\n1    1    a TRUE\n```\n:::\n:::\n\n\n## Adding to a data frame\n\nWe can add to a data frame using `rbind()` and `cbind()`, but be careful with type mismatches! We can also add columns using the column index methods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# These all do the same thing\nmy_data <- cbind(my_data, \"var4\" = c(3, 2, 1))\nmy_data$var4 <- c(3, 2, 1)\nmy_data[, \"var4\"] <- c(3, 2, 1)\nmy_data[[\"var4\"]] <- c(3, 2, 1)\nmy_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1 var2  var3 var4\n1    1    a  TRUE    3\n2    2    b FALSE    2\n3    3    c  TRUE    1\n```\n:::\n:::\n\n\n## Adding to a data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(my_data, c(1, 2, 3, 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1 var2 var3 var4\n1    1    a    1    3\n2    2    b    0    2\n3    3    c    1    1\n4    1    2    3    4\n```\n:::\n\n```{.r .cell-code}\nrbind(my_data, list(4, \"d\", FALSE, 0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  var1 var2  var3 var4\n1    1    a  TRUE    3\n2    2    b FALSE    2\n3    3    c  TRUE    1\n4    4    d FALSE    0\n```\n:::\n:::\n\n\n## Investigating a data frame\n\nWe can use `str()` to see the structure of a data frame (or any other object!)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data2 <- rbind(my_data, c(1, 2, 3, 4))\nstr(my_data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t4 obs. of  4 variables:\n $ var1: num  1 2 3 1\n $ var2: chr  \"a\" \"b\" \"c\" \"2\"\n $ var3: num  1 0 1 3\n $ var4: num  3 2 1 4\n```\n:::\n\n```{.r .cell-code}\nmy_data2 <- rbind(my_data, list(4, \"d\", FALSE, 0))\nstr(my_data2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t4 obs. of  4 variables:\n $ var1: num  1 2 3 4\n $ var2: chr  \"a\" \"b\" \"c\" \"d\"\n $ var3: logi  TRUE FALSE TRUE FALSE\n $ var4: num  3 2 1 0\n```\n:::\n:::\n\n\n## Investigating a data frame\n\nMost data frames will have column names describing the variables. They can also include rownames, which we can add using `rownames()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrownames(my_data2) <- c(\"Obs1\", \"Obs2\", \"Obs3\", \"Obs4\")\nmy_data2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     var1 var2  var3 var4\nObs1    1    a  TRUE    3\nObs2    2    b FALSE    2\nObs3    3    c  TRUE    1\nObs4    4    d FALSE    0\n```\n:::\n:::\n",
    "supporting": [
      "04_lists-data-frames_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}