{
  "hash": "bccf80b58feccc843d778118dad1b185",
  "result": {
    "markdown": "---\ntitle: \"MATH167R: Functions, vectors, and matrices\"\nauthor: \"Peter Gao\"\nformat: \n  revealjs:\n    theme: [./slides.scss, ../theme.scss]\neditor: visual\n---\n\n\n## Warm-up\n\nDiscuss the following lines of code. What do they do?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- TRUE\ny <- 3 > 4\nx <- x & y\nas.numeric(x)\n```\n:::\n\n\n. . .\n\n**Answer:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- TRUE\ny <- 3 > 4\nx <- x & y\nas.numeric(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n## Overview of today\n\n-   Functions and arguments\n-   Vectors and matrices\n-   Indexing data\n\n# Functions and Arguments\n\n## Functions {.smaller}\n\n> *\"To understand computations in R, two slogans are helpful: Everything that exists is an **object**. Everything that happens is a **function** call.\"*\n>\n> (Chambers, 2014)\n\nWe have already seen some functions, including the `sample` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsides <- 1:6\nrolls <- sample(sides, 10, replace = T)\n```\n:::\n\n\nand the `typeof` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- T\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\n**Functions** provide code to execute some task given a set of inputs.\n\n## Functions {.smaller}\n\nA **function call** is a command to execute the code of a function:\n\n`function_name(argument1, argument2, ...)`\n\n**Arguments** or **parameters** are expressions/values that are the inputs to the function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexp(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3678794\n```\n:::\n\n```{.r .cell-code}\nexp(0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nThe parentheses following the name of a function are still required even when there are no arguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls()\n```\n:::\n\n\n## Functions {.smaller}\n\nWhenever you are using a function for the first time, it is good idea to access the documentation by typing `?function_name` into the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?exp\n```\n:::\n\n\n## Specifying arguments {.smaller}\n\nA **formal argument** is a named argument that is used in the code of a function.\n\nThe function `args` displays the formal arguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(sample)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, size, replace = FALSE, prob = NULL) \nNULL\n```\n:::\n:::\n\n\nAn **actual argument** t is the value specified by the user during a function call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsides <- c(\"H\", \"T\")\nsample(x = sides, size = 1, replace = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"H\"\n```\n:::\n:::\n\n\n## Matching arguments {.smaller}\n\nThe two most common ways to specify arguments are **positional** and **exact**:\n\n-   **Positional**: the actual arguments are matched to the formal arguments in order:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(sides, 1, T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"T\"\n```\n:::\n\n```{.r .cell-code}\nsample(1, T, sides)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sample.int(x, size, replace, prob): invalid 'replace' argument\n```\n:::\n:::\n\n\n-   **Exact**: the actual arguments are matched to the formal arguments using names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample(size = 1, replace = T, x = sides)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"H\"\n```\n:::\n:::\n\n\n## Check your understanding: functions\n\nHow can we use functions to compute (feel free to look online):\n\n-   $\\ln 10$\n-   $\\log_{10} 10$\n\n. . .\n\n**Answer:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.302585\n```\n:::\n\n```{.r .cell-code}\nlog10(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n# Vectors\n\n## Atomic Vectors\n\n-   Last class, we introduced atomic vectors, but we only considered **vectors of length one**.\n\n-   Generally, atomic vectors are sets of elements of the same type.\n\n-   We create vectors using the function `c()`\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(16, 3, 0, 7, -2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 16  3  0  7 -2\n    ```\n    :::\n    :::\n\n\n## Accessing elements of vectors\n\n-   We index vectors using `[index]` after the vector name:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(16, 3, 0, 7, -2)\n    x[3]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 0\n    ```\n    :::\n    \n    ```{.r .cell-code}\n    x[4]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 7\n    ```\n    :::\n    :::\n\n\n-   If we use a negative index, we return the vector with that element removed\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x[-4]\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 16  3  0 -2\n    ```\n    :::\n    :::\n\n\n## Atomic vectors and data types\n\nNote that atomic vectors can only have one type of data. So the following lines work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(\"a\", \"b\", \"c\")\nz <- c(T, F, T)\n```\n:::\n\n\n. . .\n\nbut when we try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, \"b\", 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"b\" \"3\"\n```\n:::\n:::\n\n\nR will force the elements in our vector to be of the same type! This is a common source of bugs.\n\n## Check your understanding: vectors\n\nWhat do you expect the output of the following chunk to be?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(\"a\", \"b\", \"c\")\nc(x, y)\n```\n:::\n\n\n. . .\n\n**Answer:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(\"a\", \"b\", \"c\")\nc(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"3\" \"a\" \"b\" \"c\"\n```\n:::\n:::\n\n\nWe can use the `c()` function to concatenate vectors (forcing elements to be the same type).\n\n## Check your understanding: vectors\n\nWhat do you expect the output of the following chunk to be?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3 > 4, T, 5 > 6)\nx[3]\n```\n:::\n\n\n. . .\n\n**Answer:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(3 > 4, T, 5 > 6)\nx[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nR evaluates expressions when creating vectors.\n\n## Useful functions for vectors {.smaller}\n\n-   `max()`, `min()`, `mean()`, `median()`, `sum()`, `sd()`, `var()`\n-   `length()` returns the number of elements in the vector\n-   `head()` and `tail()` return the beginning and end vectors\n-   `sort()` will sort\n-   `summary()` returns a 5-number summary\n-   `any()` and `all()` to check conditions on Boolean vectors\n-   `hist()` will return a crude histogram (we'll learn how to make this nicer later)\n\nIf you are unclear about what any of them do, use `?` before the function name to read the documentation. You should get in the habit of checking function documentation a lot!\n\n## Generating vectors {.smaller}\n\nThe notation `a:b` generates integers starting at `a` and ending at `b`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n:::\n\n\nThe `rep` function repeats values of the first argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(\"Hello\", times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello\" \"Hello\" \"Hello\"\n```\n:::\n:::\n\n\nThe `rnorm` function randomly generates `n` elements with the specified `mean` and `sd`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(n = 10, mean = 1, sd = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  0.5685811  2.3764760  0.5958275  0.1057296  0.3593342  1.6830647\n [7]  1.3369043  1.2756476 -0.2531414  0.4183426\n```\n:::\n:::\n\n\n# Matrices\n\n## Matrices\n\n-   **Matrices** are two-dimensional extensions of vectors: they have **rows** and **columns**\n-   We can create a matrix using the function `matrix()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5)\ny <- c(5, 4, 3, 2, 1)\nmy_matrix <- matrix(c(x, y), nrow = 2, ncol = 5, byrow = TRUE)\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n:::\n:::\n\n\n## Constructing matrices\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: byrow = FALSE is the default\nmy_matrix2 <- matrix(c(x, y), nrow = 2, ncol = 5)\nmy_matrix2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    4    2\n[2,]    2    4    5    3    1\n```\n:::\n:::\n\n\n*Warning:* be careful not to call your matrix `matrix`! Why not?\n\n## Constructing matrices\n\nWe can also generate matrices by column binding (`cbind()`) and row binding (`rbind()`) vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     x y\n[1,] 1 5\n[2,] 2 4\n[3,] 3 3\n[4,] 4 2\n[5,] 5 1\n```\n:::\n\n```{.r .cell-code}\nrbind(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [,1] [,2] [,3] [,4] [,5]\nx    1    2    3    4    5\ny    5    4    3    2    1\n```\n:::\n:::\n\n\n## Indexing and Subsetting Matrices\n\nIndexing a matrix is similar to indexing a vector, except we must index both the row and column, in that order.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n:::\n:::\n\n\nWhat is the output of the following line?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[2, 3]\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n. . .\n\nWhat is the output of the following line?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[2, c(1, 3, 5)]\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 3 1\n```\n:::\n:::\n\n\n## Dropping entries\n\nAlso similarly to vectors, we can subset using a negative index.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    5    4    3    2    1\n```\n:::\n\n```{.r .cell-code}\nmy_matrix[-2, -4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 5\n```\n:::\n\n```{.r .cell-code}\n# Note: Leaving an index blank includes all indices\nmy_matrix[, -c(1, 3, 4, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n:::\n\n\n## Dropping entries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[, -c(1, 3, 4, 5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n\n```{.r .cell-code}\nis.matrix(my_matrix[, -c(1, 3, 4, 5)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nWhat happened here? When subsetting a matrix reduces one dimension to length 1, R automatically coerces it into a vector. We can prevent this by including `drop = FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_matrix[, -c(1, 3, 4, 5), drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    2\n[2,]    4\n```\n:::\n\n```{.r .cell-code}\nis.matrix(my_matrix[, -c(1, 3, 4, 5), drop = FALSE])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Filling in a Matrix\n\nWe can also fill in an empty matrix using indices. In R, you should always start by initializing an empty matrix of the right size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results <- matrix(NA, nrow = 3, ncol = 3)\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]   NA   NA   NA\n[3,]   NA   NA   NA\n```\n:::\n:::\n\n\n## Filling in a Matrix {.smaller}\n\nThen I can replace a single row (or column) using indices as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results[2, ] <- c(2, 4, 3)\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]   NA   NA   NA\n[2,]    2    4    3\n[3,]   NA   NA   NA\n```\n:::\n:::\n\n\nWe can also fill in multiple rows (or columns) at once. (Likewise, we can also do subsets of rows/columns, or unique entries). Note that **recycling** applies here.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_results[c(1, 3), ] <- 7\nmy_results\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    7    7    7\n[2,]    2    4    3\n[3,]    7    7    7\n```\n:::\n:::\n\n\n## Matrix Data Types\n\nMatrices, like vectors, can only have entries of one type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(c(1, 2, 3), c(\"a\", \"b\", \"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] \"1\"  \"2\"  \"3\" \n[2,] \"a\"  \"b\"  \"c\" \n```\n:::\n:::\n\n\n## Matrix functions {.smaller}\n\nLet's create 3 matrices for the purposes of demonstrating matrix functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 <- matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)\nmat1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n:::\n\n```{.r .cell-code}\nmat2 <- matrix(1:6, nrow = 3, ncol = 2)\nmat2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat3 <- matrix(5:10, nrow = 2, ncol = 3, byrow = TRUE)\nmat3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5    6    7\n[2,]    8    9   10\n```\n:::\n:::\n\n\n## Matrix functions {.smaller}\n\n#### Matrix Sums `+`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 + mat3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    6    8   10\n[2,]   12   14   16\n```\n:::\n:::\n\n\n#### Element-wise Matrix Multiplication `*`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat1 * mat3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    5   12   21\n[2,]   32   45   60\n```\n:::\n:::\n\n\n#### Matrix Multiplication `%*%`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat_square <- mat1 %*% mat2\nmat_square\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   14   32\n[2,]   32   77\n```\n:::\n:::\n\n\n## Matrix functions {.smaller}\n\n#### Column Bind Matrices `cbind()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(mat1, mat3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    1    2    3    5    6    7\n[2,]    4    5    6    8    9   10\n```\n:::\n:::\n\n\n#### Transpose `t()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n```\n:::\n:::\n\n\n#### Column Sums `colSums()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 7 9\n```\n:::\n:::\n\n\n#### Row Sums `rowSums()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowSums(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6 15\n```\n:::\n:::\n\n\n## Matrix functions {.smaller}\n\n#### Column Means `colMeans()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5 3.5 4.5\n```\n:::\n:::\n\n\n#### Row Means `rowMeans()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowMeans(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 5\n```\n:::\n:::\n\n\n#### Dimensions `dim()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(mat1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n:::\n\n\n## Matrix functions {.smaller}\n\n#### Determinant `det()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndet(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54\n```\n:::\n:::\n\n\n#### Matrix Inverse `solve()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsolve(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           [,1]       [,2]\n[1,]  1.4259259 -0.5925926\n[2,] -0.5925926  0.2592593\n```\n:::\n:::\n\n\n### Matrix Diagonal `diag()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiag(mat_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14 77\n```\n:::\n:::\n\n\n# Commenting Code and Style\n\n## What is a comment?\n\n-   Computers completely ignore comments (in R, any line preceded by `#`)\n-   Comments do not impact the functionality of your code at all.\n\n## So why do them...\n\n-   Commenting a code allows you to write notes for readers of your code only\n\n-   Usually, that reader is you!\n\n-   Coding without comments is ill-advised, bordering on impossible\n\n-   Sneak peak at functions...\n\n## Example {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Wald-type t test\n#' @param mod an object of class \\code{bbdml}\n#' @return Matrix with wald test statistics and p-values. Univariate tests only.\nwaldt <- function(mod) {\n  # Covariance matrix\n  covMat <- try(chol2inv(chol(hessian(mod))), silent = TRUE)\n  if (class(covMat) == \"try-error\") {\n    warning(\"Singular Hessian! Cannot calculate p-values in this setting.\")\n    np <- length(mod$param)\n    se <- tvalue <- pvalue <- rep(NA, np)\n  } else {\n    # Standard errors\n    se <- sqrt(diag(covMat))\n    # test statistic\n    tvalue <- mod$param/se\n    # P-value\n    pvalue <- 2*stats::pt(-abs(tvalue), mod$df.residual)\n  }\n  # make table\n  coef.table <- cbind(mod$param, se, tvalue, pvalue)\n  dimnames(coef.table) <- list(names(mod$param),\n                               c(\"Estimate\", \"Std. Error\", \"t value\", \"Pr(>|t|)\"))\n  return(coef.table)\n}\n```\n:::\n\n\n## Comment Style Guide\n\n-   When starting out, you should comment most lines\n-   Frequent use of comments should allow most comments to be restricted to one line for readability\n-   A comment should go above its corresponding line, be indented equally with the next line, and use a single `#` to mark a comment\n-   Use a string of `-` or `=` to break your code into easily noticeable chunks\n    -   Example: `# Data Manipulation -----------`\n    -   RStudio allows you to collapse chunks marked like this to help with clutter\n\n## Comment Style Guide\n\n-   There are exceptions to every rule! Usually, comments are to help **you**!\n\n#### Example of breaking rules\n\n-   Here's a snippet of a long mathematical function (lots of code omitted with ellipses for space).\n-   Code is divided into major steps marked by easily visible comments\n\n## Example of breaking rules {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjfun <- function(theta, W, M, X, X_star, np, npstar, link, phi.link) {\n\n  ### STEP 1 - Negative Log-likelihood\n\n  # extract matrix of betas (np x 1), first np entries\n  b      <- utils::head(theta, np)\n  # extract matrix of beta stars (npstar x 1), last npstar entries\n  b_star <- utils::tail(theta, npstar)\n\n  ...\n\n  ### STEP 2 - Gradient\n\n  # define gam\n  gam <- phi/(1 - phi)\n```\n:::\n\n\n## A final plea\n\n-   Being a successful programmer *requires* commenting your code\n-   Want to understand code you wrote \\>24 hours ago without comments?\n\n## Who are you to tell me how to type?\n\nWe will be using a mix of the [Tidyverse Style Guide](https://style.tidyverse.org/) by Hadley Wickham and the [Google Style Guide](https://google.github.io/styleguide/Rguide.html). Please see the links for details, but I will summarize some main points here and throughout the class as we learn more functionality, such as functions and packages.\n\nYou may be graded on following good code style!\n\n## Object Names\n\nUse either underscores (`_`) or big camel case (`BigCamelCase`) to separate words within an object name. Do not use dots `.` to separate words in R functions!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nday_one\nday_1\nDayOne\n\n# Bad\ndayone\n```\n:::\n\n\n## Object Names\n\nNames should be concise, meaningful, and (generally) nouns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nday_one\n\n# Bad\nfirst_day_of_the_month\ndjm1\n```\n:::\n\n\n## Object Names\n\nIt is *very* important that object names do not write over common functions!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Very extra super bad\nc <- 7\nt <- 23\nT <- FALSE\nmean <- \"something\"\n```\n:::\n\n\nNote: `T` and `F` are R shorthand for `TRUE` and `FALSE`, respectively. In general, spell them out to be as clear as possible.\n\n## Spacing\n\nPut a space after every comma, just like in English writing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nx[, 1]\n\n# Bad\nx[,1]\nx[ ,1]\nx[ , 1]\n```\n:::\n\n\nDo not put spaces inside or outside parentheses for regular function calls.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nmean(x, na.rm = TRUE)\n\n# Bad\nmean (x, na.rm = TRUE)\nmean( x, na.rm = TRUE )\n```\n:::\n\n\n## Spacing with Operators\n\nMost of the time when you are doing math, conditionals, logicals, or assignment, your operators should be surrounded by spaces. (e.g. for `==`, `+`, `-`, `<-`, etc.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nheight <- (feet * 12) + inches\nmean(x, na.rm = 10)\n\n# Bad\nheight<-feet*12+inches\nmean(x, na.rm=10)\n```\n:::\n\n\nThere are some exceptions we will learn more about later, such as the power symbol `^`. See the [Tidyverse Style Guide](https://style.tidyverse.org/) for more details!\n\n## Extra Spacing\n\nAdding extra spaces ok if it improves alignment of `=` or `<-`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nlist(\n  total = a + b + c,\n  mean  = (a + b + c) / n\n)\n\n# Also fine\nlist(\n  total = a + b + c,\n  mean = (a + b + c) / n\n)\n```\n:::\n\n\n## Long Lines of Code {.smaller}\n\nStrive to limit your code to 80 characters per line. This fits comfortably on a printed page with a reasonably sized font.\n\nIf a function call is too long to fit on a single line, use one line each for the function name, each argument, and the closing `)`. This makes the code easier to read and to change later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\ndo_something_very_complicated(\n  something = \"that\",\n  requires = many,\n  arguments = \"some of which may be long\"\n)\n\n# Bad\ndo_something_very_complicated(\"that\", requires, many, arguments,\n                              \"some of which may be long\"\n                              )\n```\n:::\n\n\n*Tip! Try RStudio \\> Preferences \\> Code \\> Display \\> Show Margin with Margin column 80 to give yourself a visual cue!*\n\n## Assignment\n\nWe use `<-` instead of `=` for assignment. This is moderately controversial if you find yourself in the right (wrong?) communities.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nx <- 5\n\n# Bad\nx = 5\n```\n:::\n\n\n## Semicolons\n\nIn R, semi-colons (`;`) are used to execute pieces of R code on a single line. In general, this is bad practice and should be avoided. Also, you never need to end lines of code with semi-colons!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bad\na <- 2; b <- 3\n\n# Also bad\na <- 2;\nb <- 3;\n\n# Good\na <- 2\nb <- 3\n```\n:::\n\n\n## Quotes and Strings\n\nUse `\"`, not `'`, for quoting text. The only exception is when the text already contains double quotes and no single quotes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bad\n'Text'\n'Text with \"double\" and \\'single\\' quotes'\n\n# Good\n\"Text\"\n'Text with \"quotes\"'\n'<a href=\"http://style.tidyverse.org\">A link</a>'\n```\n:::\n\n\n## Check-in 2\n\nIn Check-in 2, we'll practice using functions, vectors, and matrices. We'll also make practice using an .Rmd template.\n",
    "supporting": [
      "03_functions-vectors-matrices_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}